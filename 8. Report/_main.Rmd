--- 
title: "Analysing Australian Election Results"
author: "Carlos Yanez Santibanez"
date: "`r Sys.Date()`"
output: pdf_document
documentclass   : book   # article (default) report
fontsize        : 11pt      # 10pt 11pt (default) 12pt
lang            : en-GB
bibliography:
- book.bib
- packages.bib
link-citations: yes
params:
  book: FALSE
---


```{r message=FALSE, warning=FALSE, include=FALSE}
eval_book <- params$book

```


```{r setup, message=FALSE, warning=FALSE, include=FALSE}
library(DiagrammeR)
library(dplyr)
library(readr)
library(stringr)
library(here)
library(auspol)
library(flextable)
library(ggplot2)
library(tidyr)
library(fs)
library(tidymodels)
library(vip)
library(glue)
flextable::add_latex_dep(TRUE,TRUE)
source(here::here("formatting_defaults.R"))

project_path <- fs::path(here(),"..")

keep_vars <- c(ls(),"keep_vars")

```


```{r eval=eval_book, message=FALSE, warning=FALSE, include=FALSE}
uofgdataanalyticsreport::cd_page_title()
```
 
# Acknowledgements {-}


```{r eval=eval_book, message=FALSE, warning=FALSE, include=FALSE}
uofgdataanalyticsreport::cd_toc()
```

# Abstract {-}





```{r eval=FALSE, include=FALSE}
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::pdf_book")

```



<!--chapter:end:index.Rmd-->

---
output:
  pdf_document: default
---
# Introduction {#intro}



<!--chapter:end:01-intro.Rmd-->

---
output:
  pdf_document: default
bibliography:
- book.bib
- packages.bib
---

# Data {#data}

## Data Sources {#data-sources}

Data used in this project comes from two sources, namely:

-   The **Australian Electoral Commission** (AEC) [@AEC] . The national body overseeing and running federal elections, the AEC contains detailed election result records. All results for federal elections held in the 21st century are available online, through their Tally Room website [@TallyRoom].

-   The **Australian Bureau of Statistics** (ABS) [@ABS]. The ABS provides a wide number of national statistics and is responsible to conduct a national census of population and housing every 5 years. Comprehensive census data is provided in multiple formats, including CSV files through Census Data Packs [@CensusDataPack], available for censuses from 2006 onwards.

Both organisations are the authoritative source for electoral and statistical data in Australia, and the data is provided openly. Although there are no quality issues, the way that data is provided presents other challenges:

-   In both cases, data are provided in large volumes and exhaustive granularity. Data extraction and aggregation can be time-consuming and resource-intensive if not done effectively.
-   Census data points are provided using the ABS own geographical standard - and only a small selection of census data is provided already aggregated for each Commonwealth Electoral Division. Conversion between ABS geographical structures and electoral divisions is not straightforward as there is no 1:1 correspondence. Both geographical reference systems are modified at each election and each census.
-   Despite the best efforts of both organisations in keeping consistency, names of electorates, parties, and census attributes change over time, which requires keeping track of all those changes and mapping them accordingly.

To assist in dealing with these issues and ensure repeatability,  it was necessary to write code to guarantee some level of repeatability and consistency when extracting and transforming data. This resulted in three R packages being written to undertake this task:

-   **{auspol} [@R-auspol]**, which extracts and presents electoral results.
-   **{auscensus} [@R-auscensus]**, which allows to interact with Census Data Packs to extract different statistics across geographical units, and across censuses.
-   **{aussiemaps} [@R-aussiemaps]**, which assists with aggregating census data into electoral divisions, by matching and apportioning different geographical structures.

The way each package operates is described on their respective websites Using them, it was possible to build a basic data extraction and transformation pipeline, which is represented by figure \@ref(fig:data-flow).

```{r data-flow, fig.cap="Flow of data from sources to dataset", echo=FALSE}
DiagrammeR::grViz(here("img","02_data_flow.gv"))
```

In four steps, the extraction process consists of:

1.  Census data was extracted from the respective Census Data Pack using **{auscensus}**. Using the package workflow, key attributes were identified in each census, extracted from the respective files and given common names. Data were extracted for statistical areas and apportioned into Commonwealth Electoral Divisions by overlapping area, with the help of functions written into **{aussiemaps}**

2.  Primary vote results for each division were extracted using the **{auspol}** package.

3.  All the data was stored in a local database, from where it was extracted and put together in a single dataset.

4.  From there, the "raw" data was further processed and stored in a single "consolidated" dataset. This dataset has been further refined throughout the data exploration and modelling steps.

## Data Selection and Initial Transformation {#data-selection}

There were a number of considerations that were taken to obtain the dataset that was eventually used, including what and how to represent the statistics and how to best align census and election data.

### How to present the numbers

The first point to consider was how to represent the data in a way that is consistent across electorates and time.
Although the aim behind the creation and geographical distribution of Commonwealth Electoral Division is to provide equal representation in Parliament for every Australian, this is not completely possible in practice, resulting in electorates varying in population (between 72,345 and 138,836 voters). This is mainly due to the large variation in population density across Australia, combined with a constitutional mandate to guarantee a minimum number of seats per state or territory. For this reason, it is deemed necessary to represent all voting and demographic statistics as a percentage of each electorate's roll or population. This is also useful when comparing statistics across time.



The second point to address is the correspondence between census and election data. Since the election the census cycle (5 years) does not match the electoral cycle (determined by the incumbent government, with a 3-year term for the House of Representatives), there is a potential problem of the census data not being completely representative of the population on a given election day. Figure \@ref(fig:electionsandcensus) presents the best matches between both events held in the 21st century.

```{r electionsandcensus, fig.cap="Census and Elections Timeline"}
 tibble::tribble(~Year, ~Event,
                2001,"Census",
                2006,"Census",
                2011,"Census",
                2016,"Census",
                2021,"Census",
                2001,"Election",
                2004,"Election",
                2007,"Election",
                2010,"Election",
                2013,"Election",
                2016,"Election",
                2019,"Election",
                2022,"Election"
                ) |>
  mutate(start = lubridate::ymd(Year,truncated = 2L),
         end=start+lubridate::ddays(365)) |>
vistime::gg_vistime(col.event="Year",col.group = "Event", title = "Timeline of Census and Elections") 

```

Considering the census data available and selecting the elections closer to each census, four sets of events were selected for data extraction. there are presented in table \@ref(tab:selected-pairs)

```{r }

tibble::tribble(~Census,~Election,
                "2006","2007",
                "2010","2011",
                "2016","2016",
                "2021","2022") |>
   flex_default("Selected Census-Election pairings","selected-pairs") |>
   set_table_properties( width = .8, layout = "autofit") |>
   align(j=1, align = "right", part = "all")

```

Please note that this selection will remove half of the election events within the period, which may affect model accuracy. However, since the objective is not to obtain an accurate prediction this has been accepted as an acceptable trade-off to avoid, instead of having to interpolate demographic statistics.

### Electoral Data {#data-selection-electoral}

In the case of the electoral data. not much processing was required. The source data already contains records of primary voting for each electorate.  The only adjustment was to reclassify the vote into four groups (referred to as parties in this document):

* **ALP** for the Australian Labor Party.
**COAL** representing the Coalition, made of the Liberal Party, the National Party, the Liberal National Party of Queensland [^04-data-lnp] and the Country Liberal Party in the Northern Territory [^04-data-lnp] .

[^04-data-lnp]: In Queensland and the Northern Territory, the Liberal and National branches have merged. Elected federal MPs and senators sit with Liberals if they come from an urban area, or the Nationals when they represent a regional/rural/remote electorate.



 A data sample is presented in table \@ref(tab:canberra2022).

```{r}

auspol::house_primary_vote_summary(division="Canberra",
                                   year=2022,
                                   parties = c("ALP","LP","GRN"),
                                   include_others = TRUE) |>
  mutate(Year=as.character(Year)) |>
  mutate(PartyNm=case_when(
    PartyAb =="Other" ~ "Other Parties",
    PartyAb =="LP" ~ glue::glue("{PartyNm} (Coalition)"),
    TRUE ~ PartyAb
  ),
  PartyAb = case_when(
    stringr::str_detect(PartyNm,"Coalition") ~"COAL",
    TRUE ~ PartyAb
  )) |>
  mutate(Percentage=OrdinaryVotes/sum(OrdinaryVotes)) |>
  select(Year=Year,
         Division=DivisionNm,
        Abbreviation=PartyAb,
        Party=PartyNm,
        Votes=OrdinaryVotes,
        Percentage=Percentage) |>
  flex_default("Sample extraction - Canberra 2022","canberra2022") |>
    set_formatter( Percentage = function(x) sprintf( "%.1f%%", x*100 ) ) |>
  autofit()

```

### Census Data

```{r include=FALSE}
dataset <- read_csv(fs::path(project_path,"4. Data","consolidated.csv"))
census_cols <- dataset[1,] |> select(-any_of(c(party_cols,"DivisionNm",
                                               "StateAb","")),
                                     -matches("[Yy]ear"),-starts_with("Metro")) 

census_cols <- ncol(census_cols)

```

When it comes to Census data, a number of considerations had to be tackled during extractions, namely:
* **Large volumes of data**. Each census collected a large number of statistics. For instance, the data release for the 2022 Census contains 62 different tables, ranging from 8 [^04-data-1] to 1,590 [^04-data-2] attributes.
* **Data aggregated per electorate**. Although the ABS provides statistics for *non ABS* geographical structures, this only includes a subset of all data points collected. Thus, in many cases is necessary to extract data for granular-level ABS units (*SA1* in 2022) and aggregate them into electoral divisions. Without knowing the population density for each SA1, values have been approximately apportioned using areas.
* **Consistency across time**. Due to the changing nature of a Census (to better serve its purpose), there are some minor variations in how data is collected and aggregated from Census to Census. 

[^04-data-1]: *02 -Selected Medians and Averages*

[^04-data-2]: *09 - Country of Birth of Person by Age by Sex*

To obtain a first selection of potentially relevant demographic variables to extract, existing literature and journalistic sources were consulted ([@biddle2022], [@votingpatternsbygen], [@jakubowicz]). Since many variables are colinear by definition (e.g. income groups) or they are closely related (e.g age and relationship status), the initial selection was inspected. After iteration, a resulting set of `r census_cols` attributes was chosen, which can be classed into the following categories:

1.  **Income**: Distribution of the population in pre-set income brackets. The highest income bracket includes everyone earning 2,000 dollars or more each week.

2.  **Education Level**: Distribution of educational achievement (from incomplete secondary to vocational education and academic degrees).

3.  **Age**:  Year of birth is captured in the census, which was grouped into generational cohorts. The four groups of interest are Baby Boomers (1946 to 1964), Generation X (1965 to 1980), Generation Y (1981 to 1996) and Generation Z (1997 to 2021).

4.  **Relationship status**: Variables describing civil status (e.g. living alone, married, in a de facto relationship).

5.  **Household type:** Descriptors of type of housing, (e.g. standalone house, semi-detached, flats).

6.  **Household tenure:** Descriptors of house ownership, rental or another arrangement (e.g. public housing).

7.  **Citizenship**: Percentage of the population that hold Australian citizenship. Although non-citizens are not entitled to vote, this variable can be taken as a proxy for the relative integration of migrant communities into civic life.

8.  **Religion:** Percentage of the population declaring to profess a religion. For this analysis, large and high-growth religious groups were selected. For practical reasons and to use as a potential community proxy, the values of Anglican, Presbyterian and Uniting followers were merged into a single statistic.

9.  **Language**: Languages spoken in the community. Similar to religion, a selection of relevant languages have been included to reflect the historic and current migrant communities.

Additionally, each electorate was classified as **metropolitan** if it lies within the boundaries of Australian capital cities or **non-metropolitan**, when it is not the case. Altogether, these variables try to reflect wealth and education (cited by [@biddle2022] as key factors influencing political persuasion), as well as the stage in life and belonging to a particular migrant community (sometimes cited as an influential factor, for instance in [@jakubowicza]).

A sample of the resulting dataset is present in table \@ref(tab:datasetsample).

```{r include=FALSE}
dataset <- read_csv(fs::path(project_path,"4. Data","consolidated.csv"))

```

```{r}
dataset |> 
  slice_sample(n=8) |>
  select(election_year,DivisionNm,ALP,COAL,GRN,Other,
         Australian_Citizens,Age_Baby_Boomers,Age_Gen_X,
         Language_Chinese,Language_Greek) |>
  mutate(election_year=as.character(election_year)) |>
  mutate(across(where(is.numeric),~round(.x,2))) |>
  flex_default("Dataset sample","datasetsample") |>
  rotate(rotation="btlr",align="bottom", part = "header") |>
  autofit()

```

## Training, Validation and Testing Split

After obtaining the data, the election results and census statistics for the 2021/2022 cycle were set aside, since they have been used as testing dataset, in a election forecast attempt. The remaining data has been used in exploratory analysis, data mining and creating and fitting models.

## Data Exploration {#eda}

In total, the resulting dataset is made up of 4 response variables and `r census_cols` potential predictors, plus identification attributes like division name and election year. As expected the many covariates exhibit moderate to high collinearity. Also, it is possible to observe some loose correlation between some of the covariates and some of the responses

As an example, figure \@ref(fig:coalvsboomers) shows a somewhat weak correlation between Coalition primary vote and the percentage of the Baby Boomers. Figure \@ref(fig:corrlanguagereligion) presents the correlation values for religion and language variables, where is possible to see:
* A positive correlation between monolingual English speakers and membership in Anglican, Presbyterian and Uniting churches. Together, they are likely proxies for Anglo-Celtic population.
* Similarly, there are somewhat expecting origins that most likely indicate concentrations of linguistically and culturally diverse pockets, e.g. Hinduism and South Asian languages, Catholicism and Italian, and Buddhism and East Asian languages. 

```{r coalvsboomers,fig.cap="Correlation between Coalition vote and Baby boomer population"}
dataset |>
  select(DivisionNm,election_year,COAL,Age_Baby_Boomers) |>
  ggplot(aes(x=Age_Baby_Boomers,y=COAL)) +
  geom_point(colour=auspol::party_colours()["COAL"]) +
  facet_wrap(.~ election_year, ncol=2) +
  labs(title="Coalition Primary vote by baby boomer population",
       subtitle="as percentage of electorate's population",
       x= "Baby Boomers (%)",y="Primary vote (%)")
```

```{r corrlanguagereligion, echo=FALSE,  out.width="110%", fig.cap="Correlation for selected covariates"}

cor_selection <-dataset |>
  select(matches("Religion"),
         matches("Language")) |>
  filter(!is.na(Religion_Catholic))

cor_columns <- colnames(cor_selection)
names(cor_columns) <- str_replace_all(cor_columns,"_"," ")
names(cor_columns) <- str_replace_all(names(cor_columns),"Language","Language:")
names(cor_columns) <- str_replace_all(names(cor_columns),"Religion","Religion:")

cor_columns <- sort(cor_columns)

cor_selection <- cor_selection |>
                 select(any_of(cor_columns)) |>
                 rename(any_of(cor_columns)) 

col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))

cor(cor_selection) |>
     ggcorrplot::ggcorrplot( hc.order = FALSE, 
                             type = "lower",
                             tl.cex=8,
                             lab = TRUE,
                             lab_size=1.5) +
  labs(title="Correlation between Language and Religion") +
  guides(fill=guide_legend(title="Correlation"))
  
```

Additionally, after a detailed inspection, it is worth noticing that :

-   There is no apparent change in the relationship between a given covariate and the responses when broken down by state or capital city.

-   There are no obviously distinguishable differences when splitting results by each election.

### Dimensionality reduction using Multiple Factor Analysis {#data-mfa}

Given the large number of colinear covariates, it is worth exploring if a change of space could help to better measure variation in a meaningful way and in a more manageable number. To achieve this,  **multiple factor analysis* (MFA) [@escofier:hal-00382085] was used as  the clustering algorithm. MFA is essentially an extension of Principal Component Analysis that can deal with variables that belong to groups (like this case). It can also combine quantitative and qualitative variables (such as belonging to a metropolitan area). 

The resulting scree plot and cumulative variance are presented in figure \@ref(fig:mfascree).

```{r include=FALSE}
library(factoextra)
library(patchwork)

mfa <- readRDS(fs::path(project_path,"6. Modelling",
                         "clustering_models","MFA.rds"))
```

```{r mfascree, fig.cap="Scree plot and cumulative variance"}
screeplot <- fviz_screeplot(mfa)  +
             labs(y="Percentage of Variance")

variance_data <- mfa$eig |> 
  as_tibble() |>
  mutate(across(where(is.numeric), ~ round(.x,3))) |>
  mutate(Dimension=as.character(row_number()), .before=1) |>
  select(Dimension,`percentage of variance`)  |>
   slice_head(n=10)

variance_plot <- variance_data |> 
  waterfalls::waterfall(calc_total = FALSE,
                        rect_text_labels  = round(variance_data$`percentage of variance`,2),
                         put_rect_text_outside_when_value_below=40) +
  theme(axis.title.y = element_text(),
        axis.title.x = element_text()) +
  labs(title="Cumulative Variance",
       y="Percentage of Variance",
       x="Dimensions") +
  ylim(0,100)
  

screeplot / variance_plot 

```

Figure \@ref(fig:groupbiplot) presents group biplots for the 8 most important dimensions. Unfortunately, there is no straightforward representation except with Dimension 2 and Education variables.

```{r groupbiplot,fig.cap="Group plots for first 8 dimensions"}
mfa_plot <- list()
for(i in 1:4){
  mfa_plot[[length(mfa_plot)+1]] <-   fviz_mfa_var(mfa,choice="group",axes=c(2*i-1,2*i)) + 
                                      xlim(0,1) + ylim(0,1) +
                                      theme(plot.title = element_blank())
}

wrap_plots(mfa_plot) + plot_annotation(title="Variable groups - MFA")

```

### Electorate segments {#data-clusters}

Normally when characterising votes, Australian politicians and political media make a distinction between inner-city voters (touted as wealthy and progressive), suburbia (“middle Australia”), and the bush and outback areas (conservative, “battlers”, “real Australia”). Therefore, it is of interest to explore if this can be substantiated by demographic attributes, as it may have an impact on primary voting. 

Using all demographic variables a clustering algorithm has been applied to identify those clusters. Different clustering approaches were, eventually choosing to:

- ignore Census years and pool all records in a single pool.   
- transform all demographic attributes to represent the difference between each data point and their corresponding national value (in the same year).
-  use HDBSCAN [@campello2013], a density-based hierarchical clustering algorithm. Instead of pre-setting a target number of clusters, HDBSCAN determines the optimal number of clusters based on its tuning parameters. 

This results in 3 distinct clusters of electorates. When presented in a map, it is possible to obtain  figure \@ref(fig:clustermap2016) for 2016.

```{r clustermap2016, echo=FALSE, fig.cap="Clusters for 2016 Election"}
library(sf)

clusters <- read_csv(fs::path(project_path,"4. Data","clusters.csv")) |>
            filter(Year==2016) |>
            mutate(cluster=as.character(cluster))

australian_ced_map(clusters,fs::path(project_path,"4. Data","CED_2016.gpkg"),
                   "cluster",clusters_colours,
                    "Clustering of 2016 Electoral Divisions")

```

These three clusters are: 

-   **cluster 0** seems to mostly contain electorates located in the inner cities, especially in Sydney and Melbourne. These areas tend to be more affluent, either "established" or "gentrified" suburbs. Notably, it also contains the three northernmost, remote electorates.

-   **cluster 1** comprises all regional areas outside state capitals (with the exception of Hobart in Tasmania).

-   **cluster 2** largely represents "suburbia". It is also more prevalent in Brisbane and Perth compared when comparing capital cities.

Revisiting the demographic attributes can help to understand how these clusters differ from each other. A selection of those variables is presented in figure \@ref(fig:clustereddemographics).

```{r clustereddemographics, fig.cap="Selected attributes, coloured by cluster."}

dataset |>
  left_join(clusters,by="DivisionNm") |>
  select(DivisionNm,cluster,all_of(c("Australian_Citizens",
                           "Age_Gen_Y","Age_Baby_Boomers",
                           "Language_Chinese",
                           "Religion_No_Religion_Secular",
                           "Religion_Anglican_Uniting_Presbyterian",
                           "Income_2000_or_more",
                           "Education_Bachelor",
                           "Education_Diploma_or_Certificate",
                           "Relationship_Married"))) |>
  pivot_longer(-c(DivisionNm,cluster),names_to = "Attribute",values_to="Value") |>
  ggplot(aes(y=Attribute,colour=cluster,x=Value),alpha=0.4) +
  ggbeeswarm::geom_quasirandom(size=2) +
  theme_minimal()+
  scale_colour_manual(values=clusters_colours) +
  labs(title = "Selected Attributes by cluster")

```

Even though it is possible to find electorates from every country across the spectrum for every attribute, it is possible to observe that cluster 0 tends to concentrate areas with significant Millenial, highly educated, and relatively affluent populations. These areas also tend to attract newer migrants (lower numbers of citizens) and therefore they possess higher percentages of multicultural populations (such as Chinese speakers). Cluster 1 tends to concentrate older people, with lower percentages of tertiary and vocational education and possibly higher proportions of Anglo-Celtic Australians.  Cluster 2 seems to be sitting in the middle of the other two clusters. Adding these findings to the geographical locations seems to confirm there is some element of truth in the stereotypical classification of voters.

```{r}
rm(list=ls()[!(ls() %in% keep_vars)])
```

<!--chapter:end:02-data.Rmd-->

---
output:
  pdf_document: default
bibliography:
- book.bib
- packages.bib
---
# Method {#method}

Going back to the introduction, the objective of the exercise is to determine if demographic attributes can influence or explain voting patterns. This can be restated into determining if demographic attributes can serve as predictors of primary voting. In mathematical terms, this can be expressed in a simple way by  S equation \@ref(eq:equation1).

```{=tex}
\begin{align}
\mathbf{Y} = f(\mathbf{X})
(\#eq:equation1)
\end{align}
```
where $\mathbf{Y}$ represents a vector with primary voting for an electorate, and $\mathbf{X}$ represents the vector of respective demographic attributes. 

In this simple form, other factors that may influence voting are not explicitly shown in the equation. However, these factors may be difficult to quantify as they potentially relate to a myriad of factors including the state of the economy, foreign affairs, perceptions about the governing party or any party in the election, or the mood of the times.

To solve this challenge, it is possible to naively assume tools like polling can effectively capture the *zeitgeist*. If that is the case, it is possible to split the original function $f()$ into a poll component and a demographic component. Since it is not in the scope of this project, we can also ignore the polling component and focus on the difference between the absolute value and polling results. To further simplify things, we can temporarily assume that polling results are uniform across the country, thus demographic statistics only influence the difference between the electorates' primary vote and the respective national percentage. This is expressed by equation  \@ref(eq:equation2), which also accounts for general error.

```{=tex}
\begin{align}
\mathbf{Y} = f(\mathbf{X}) + \epsilon \\ \\
\textrm{where}  \\
\mathbf{Y}  = \mathbf{Y} - \mathbf{Yp} \\
\mathbf{X}  = \mathbf{X} - \mathbf{Xn} \\ \\
\textrm{and}  \\
\mathbf{Yp} : \textrm{Primary voting polling results} \\
\mathbf{Xn} : \textrm{Demographic values at national level}
(\#eq:equation2)
\end{align}
```
This second iteration does not take into account that in different electorates, different demographic attributes may have a different effect on the primary vote. For instance, in more progressive areas, a higher proportion of younger people may have a greater effect on left-leaning preferences when compared with similar proportions of younger people in rural electorates.  Equation  \@ref(eq:equation3) is intended to acknowledge those differences.
  
```{=tex}
\begin{align}
\mathbf{Y_i} = f_i(\mathbf{X_i}) + \epsilon \\
\textrm{where}  \\
\mathbf{Y}  = \mathbf{Y} - \mathbf{Yp_i} \\
\mathbf{X}  = \mathbf{X} - \mathbf{Xn_i} \\ \\
(\#eq:equation3)
\end{align}
```
      
Please note that $i$ represents a particular grouping of electorates,  and for each group predictors can be different - as different attributes may have different impacts.
    
In terms of choosing an appropriate $f_i$, it would depend on the objective of the model. Given the large number of predictors and requirements on interpretability and accuracy, this could be a complex task. In this particular case, the focus is on understanding the factors that influence voting rather than producing accurate electoral predictions (which is attempted nevertheless), for which the use of **regularised regression** models is an appropriate choice. 

Consequently,  the task at hand consists in finding the regularised regression coefficients for the set of formulas represented by equation \@ref(eq:equation4)
    
```{=tex}
\begin{align}
\left(\begin{array}{c} 
y_{i1}\\ 
y_{i2}\\ 
... \\
y_{in}\\ 
\end{array}\right) =
\left(\begin{array}{cccc} 
\beta_{i11} & \beta_{i12} & ... &  \beta_{i1m}\\
\beta_{i21} & \beta_{i22} & ... &  \beta_{i2m}\\
 ...         & ...         & ... & ...         \\
\beta_{in1} & \beta_{in2} & ... &  \beta_{inm}\\
\end{array}\right)
\left(\begin{array}{c} 
x_{i1} \\
x_{i2} \\
...    \\
x_{im}
\end{array}\right) +
\left(\begin{array}{c} 
\epsilon_{i1}\\ 
\epsilon_{i2}\\ 
... \\
\epsilon_{in}\\ 
\end{array}\right)
(\#eq:equation4)
\end{align}
```
        
A complication of this approach is that requires separating the electorates into different segments. This requires having a method to map electorates into clusters if such an assignment is not provided. Thus, the modelling task consists of:
        
- A classification model map new records into clusters with similar electorates.
- A regularised regression model to determine how demographic factors influence primary voting for each party.      



```{r}
rm(list=ls()[!(ls() %in% keep_vars)])
```

<!--chapter:end:03-method.Rmd-->

---
output:
  pdf_document: default
  html_document: default
bibliography:
- book.bib
- packages.bib
---

# Fitting and analysing a model {#modelling}

As mentioned in the previous section, this exercise requires fitting both a classification and regularised regression model.

## Cluster classification {#clusterclassifier}

Although HDBSCAN can be used to map new data points into the existing clusters, a different approach has been taken: to "reverse engineer" the clusters by training a classification model. The intent behind this is to leverage the trained model to identify the main contributors to the classification.

Different models were tried, starting with basic tree partitioning. After a couple of trials, a **random forest** model was selected. The algorithm was trained with:

-   Census data from 2007 to 2016 (mirroring elections between 2006 to 2016),wich was used for training and validation.
-   Values for demographic attributes, which were centred around the overall percentage for said attribute, for the respective cluster.
-   Clusters previously obtained with HDBSCAN, used as the response variable.
-   Since the year has been "discounted", all values will be considered as one pool. An assumption has been made that the period in question is short enough to drastically affect the clustering model. If demographic values change - cluster assignment (for instance because of re-distribution), the effect is similar to being a different electorate.

The initial fitting produces the results presented in tables \@ref(tab:ranger11) and \@ref(tab:range12). A variable importance plot is also presented in figure \@ref(fig:vipranger1)

```{r}
clustering_folder <-path(project_path,"6. Modelling","clustering_models")
ranger1 <- readRDS(path(clustering_folder,"clustering_ranger.rds"))

ranger1 |>
    collect_metrics() |>
  select(.metric,.estimate) |>
  flex_default("First Model","ranger11")
```

```{r}
ranger1$.predictions[[1]] |>
  select(all_of(c(".pred_class","cluster"))) |>
  mutate(correct=(.pred_class==cluster)) |>
  count(cluster,correct) |>
  group_by(cluster)      |>
  mutate(n=n/sum(n))     |>
  pivot_wider(names_from="correct",values_from=n) |>
   flex_default("First Model","ranger12")
```

```{r}

extract_workflow(ranger1) |>
  extract_fit_parsnip() |>
  vip()
```

From the chart above, it is possible to see that only a handful of variables significantly contribute to the cluster selection. Aiming for simplification, a random forest model with reduced variables was also trained, achieving similar results in accuracy and variable importance (shown in tables \@ref(tab: ranger21) and  \@ref(tab:ranger22), and figure \@ref(fig:vipranger2).

```{r}
ranger2 <- readRDS(path(clustering_folder,"clustering_ranger_redux.rds"))

ranger2 |>
    collect_metrics() |>
  select(.metric,.estimate) |>
  flex_default("First Model","ranger11")
```

```{r}
ranger1$.predictions[[1]] |>
  select(all_of(c(".pred_class","cluster"))) |>
  mutate(correct=(.pred_class==cluster)) |>
  count(cluster,correct) |>
  group_by(cluster)      |>
  mutate(n=n/sum(n))     |>
  pivot_wider(names_from="correct",values_from=n) |>
   flex_default("First Model","ranger12")
```

```{r}

extract_workflow(ranger2) |>
  extract_fit_parsnip() |>
  vip()
```

Looking at variable importance, it is possible to appreciate that cluster placement can be driven by :

-Location in a large metropolitan area or the regions. 
-Population density, (type of household) 
-Life stage (relationship)
-Wealth (type of household ownership)
-Multicultural makeup of the area - first and second-generation migrants are more likely to be bilingual - thus the proportion of monolingual people is a proxy variable for this.

This picture fits with the media narrative about differences in the electorate (quote).

```{r}
 rm(list=ls()[!(ls() %in% keep_vars)])
```

## Regularised regression {#glmnet-regression}

Due to the large number of variables, the first step is to see if it is possible to identify which factors may be of influence. For this, a Lasso regression was conducted with the sole intent of variable selection. Then an elastic net was fitted, with the goal to optimise the root square mean error (RMSE). This process was done separately for each cluster. Although precision is not a key objective of this exercise, table \@ref(tab:bestresults) presents the best RMSE result per cluster, alongside the selected tuning parameters.

```{r}

enet_folder <- path(project_path,"6. Modelling","elastic_net_eval")
regression <- list()
for(i in 0:2){
    message(glue::glue("cluster_delta_cluster_cluster{i}.rds"))
    regression[[length(regression)+1]] <- readRDS(path(enet_folder,glue::glue("cluster_delta_cluster_cluster{i}.rds")))
}
names(regression) <- str_c("cluster ",0:2)

```

```{r}
best_parameters <- tibble()

for(i in 1:3){
  best_parameters <- bind_rows(best_parameters,
                      regression[[i]] |>  
                      filter(RMSE_Overall==min(RMSE_Overall)) |>
                      select(-coefs,-number) |>
                      add_column(cluster=i-1,.before=1) |>
                      select(cluster,alpha,lambda,
                             RMSE_Overall,RMSE_GRN,
                             RMSE_ALP,RMSE_COAL,RMSE_Other
                             )
  )  
}

header_key <- tibble(col_keys = colnames(best_parameters)) |>
              mutate(second_row=case_when(
                col_keys == "cluster"  ~ "Cluster",
                col_keys == "alpha"    ~ "⍺",
                col_keys == "lambda"   ~ "λ",
                str_detect(col_keys,"RMSE")  ~  str_remove_all(col_keys,"RMSE_")
              )) |>
              mutate(first_row=case_when(
                col_keys == "cluster"  ~ "Cluster",
                col_keys == "alpha"    ~ "⍺",
                col_keys == "lambda"   ~ "λ",
                str_detect(col_keys,"RMSE")  ~   "RMSE"
              )) |>
            select(col_keys,first_row,second_row) 


best_parameters |>
  mutate(cluster=as.character(cluster)) |>
  mutate(across(where(is.numeric), ~ round(.x,4))) |>
  flex_default("Best Results for each cluster","bestresults") |>
  set_header_df( mapping = header_key, key = "col_keys" )     |>
  merge_v(part = "header", j = 1:3) |>
  merge_h(part = "header", i = 1) |>
  theme_booktabs(bold_header = TRUE) |>
  align(align = "center", part = "header") |>
  vline(j = c(1, 3), border = fp_border_default()) 
  

```

However, the main objective is to understand the coefficients for each covariate, which are presented in figure \@ref(fig:betacoefficients).

```{r}
#load data

dataset <- read_csv(path(project_path,"4. Data","consolidated_cluster.csv"))      |>
           filter(election_year!=2022)                       |>
           select(-any_of(c("Metro_Area")))              |>
            mutate(across(where(is.numeric), ~ replace_na(.x,0)))

clusters <- read_csv(path(project_path,"4. Data","clusters.csv"))         |>
            select(-any_of(c("Metro_Area")))

dataset <- dataset |>
           left_join(clusters,by=c("DivisionNm"="DivisionNm","election_year"="Year"))

rm(clusters)

vote <- dataset |> select(DivisionNm,Year,election_year,StateAb,Metro,cluster,all_of(party_cols))

cluster_avg <- read_csv(path(project_path,"4. Data","cluster_values.csv")) |>
             filter(Year!=2021) |>
             pivot_longer(-c(Year,cluster),
                          names_to = "Attribute",values_to="National") |>
             mutate(Attribute=str_replace_all(Attribute," - ","_"),
                    Attribute=str_replace_all(Attribute,"-","_"),
                    Attribute=str_squish(Attribute),
                    Attribute=str_replace_all(Attribute," ","_")) 

rest <- dataset |> 
        select(-all_of(party_cols)) |>
        select(-Metro,-StateAb,-election_year) |>
         pivot_longer(-c(DivisionNm,Year,cluster),
               names_to = "Attribute",values_to = "CED") |>
         mutate(Year=as.numeric(Year))                   |>
         left_join(cluster_avg,
            by=c("Year","Attribute","cluster")) |>
          select(-cluster) |>
          mutate(Value=CED-National,.keep="unused") |>
          pivot_wider(names_from = Attribute, values_from = Value)

dataset <- vote |>
           left_join(rest,by=c("DivisionNm","Year")) |>
           mutate(Division=str_c(DivisionNm,"-",election_year),.keep="unused") |>
          select(-any_of(c("Year","Household_Semi_detached"))) |>
          select(-any_of(c("StateAb","Metro")))

variances <- dataset |>
  select(-all_of(c(party_cols,"Division"))) |>
  group_by(cluster) |>
  summarise(across(everything(), ~var(.x)))   |>
  pivot_longer(-cluster,names_to="covariate",values_to="variance")

rm(rest,vote,dataset)

```

```{r betacoefficients,fig.cap="Resulting coefficients per cluster", fig.height=20, message=FALSE, warning=TRUE}
library(patchwork)

p <- list()
for(i in 1:3){
   data     <- (regression[[i]]                        |> 
                          filter(RMSE_Overall==min(RMSE_Overall)) |>
                          pull(coefs))[[1]]                       |>
                          pivot_longer(-covariate,names_to="PartyAb",values_to = "coefficient") |>
                          mutate(cluster=names(regression)[i],.before=1) |>
                left_join(variances |> filter(cluster==(i-1)),
                          by=c("covariate")) |>
                mutate(covariate=glue::glue("{covariate} ({round(variance,2)})")) |>
                mutate(covariate=str_remove_all(covariate,"\\(NA\\)")) |>
                mutate(variance = if_else(is.na(variance),0,variance)) |>
                mutate(covariate=forcats::fct_reorder(covariate,variance)) |>
                select(covariate,coefficient,PartyAb)
   
    max_coeff <- max(abs(data$coefficient))
    scale_breaks <- c(0,1,2,round(max_coeff/2,0),ceiling(max_coeff))
    scale_breaks <- c(-scale_breaks,scale_breaks)
    scale_breaks <- unique(scale_breaks)
  
    p_i <-    data |> 
                ggplot(aes(y=covariate,x=coefficient,colour=PartyAb)) +
                geom_vline(xintercept = 0) +
                geom_point(size=3.5,shape=18) +
                scale_colour_manual(values=party_palette,name="Party") +
                scale_x_continuous(trans=scales::pseudo_log_trans(), breaks=scale_breaks) +
                labs(subtitle= cluster_names[i,]$name_composite,
                     x="coefficient") +
                theme(axis.title.y =element_blank())
                

    if(i==3){
      p_i <- p_i +
            theme(legend.position = "bottom",
                  legend.direction = "horizontal")
    }else{
      p_i <- p_i + 
            theme(legend.position = "none",
                  axis.title.x = element_blank())
    }
    
  p[[length(p)+1]] <- p_i

}

wrap_plots(p,ncol=1) +
  plot_annotation(title="Coefficients by cluster",
                  subtitle="Covariate's variance in brackets") +
  ggh4x::force_panelsizes(rows = 16, cols = 1)

```

It is worth noticing that some of the selected covariates may not be relevant in all electorates, by account of their small absolute various or being relatively uniform across the segment. For this reason, the covariates in figure \@ref(fig:betacoefficients) have been ordered by their respective variance - when assessing their overall effect / relevance this must also be taken into account.

When looking at each cluster, it is possible to summarise the different demographic effects as follows:

-   In **cluster 0** (mostly inner metropolitan areas) political divides are drawn across wealth, religiosity (i.e. values) and generational lines.

    -    In these areas, coalition vote is associated with higher percentages of followers of Anglican, Uniting and Presbyterian churches, people on higher income and Baby Boomers.
    -   Labor vote is turn driven by followers of the Catholic Church (partially a reflection of the historic association between the Australian Catholic Church and the labour movement, and Irish and Italian migration) and Millennials. There is some association between less-advantaged populations and social and community housing.
    -   Green vote is also driven by Millennials, but unlike Labor there is a positive association with higher income groups. Green votes are also related to the irreligiosity o secular population groups.

-   In **cluster 1** (regional areas, including midsize cities and rural areas), demographic variance is smaller. However, when it happens, it follows a different pattern from the main cities.

    -   In this area, the Coalition vote has also a positive association with religiosity - this is not dissimilar to cluster 1, especially when considering that Anglicanism/Presbytiarism/Unitiarism are the largest religious groups in the area). However, a key difference with the cities is that in case higher wealth groups have a negative association with Coalition vote.
    -   Labor vote in these areas is driven by a larger proportion of Australian citizens and higher-income voters.
    -   Overall, it seems there are no demographic factors influencing Green votes in these areas.
    -   Interestingly, age does not rank as a variable of importance.

-   As expected, **cluster 2** (metropolitian suburbia), shares some traits with their inner-city counterparts, showing the same associations along religious, age and wealth lines. However, there are a larger number of predictors associated with the multicultural makeup of the electorates. Those covariates tend to have a positive effect on Labor vote and a negative influence on Coalition and Green voting. This difference is interesting, especially considering inner city areas are as multicultural as the suburbs.

```{r}
rm(list=ls()[!(ls() %in% keep_vars)])
```

<!--chapter:end:04-model.Rmd-->

---
output:
  pdf_document: default
bibliography:
- book.bib
- packages.bib
---

# Results {#results}

```{r hundred-setup,message=FALSE,warning=FALSE,echo=FALSE}

results <- readRDS(path(project_path,"7. Forecast","results.rds"))
```

## Forecasting the 2022 Federal Election {#2021prediction}

The previously fitted model can be used to attempt to retroactively forecast the 2022 Federal Election. Through this process, it is possible to illustrate the model's strengths and shortcomings in capturing how demographic factors succeed and fail to capture the change in voting patterns.

This exercise uses the results from the 2021 Census of Population and Housing. The base voting percentages are taken from the last Newspoll prior to the election [@NewsPoll] . Newspoll is usually considered a good predictor of the Australian election. The values are shown in table \@ref(tab:newspoll). Please note these values are national - but since there is no cluster-level data, they will use regardless.

```{r}
results$newspoll |>
  rename("Party"="PartyAb","Forecast"="Avg.Vote") |>
  mutate(Forecast=glue("{Forecast}%")) |>
  flex_default("Newspoll Primary Vote Forecast, 20 May 2022","newspoll") |>
  theme_booktabs() |>
  width(j=1,10,"mm") |>
  width(j=2,20,"mm") |>
  align(j=2,align="right")
```

The first step in the forecasting process is to map the electorates into three clusters. The result is presented in figure \@ref(fig:2022cluster).

```{r 2022cluster,fig.cap="Cluster in 2022 Election",warning=FALSE,message=FALSE}
results$new_data |> 
  select(Division,cluster,Metro_Area) |>
  mutate(DivisionNm=str_remove(Division,"-2022"),.keep="unused") |>
  mutate(DivisionNm=str_remove(DivisionNm," \\(II\\)")) |>
  australian_ced_map(
                   path(project_path,"4. Data","CED_2021.gpkg"),
                   "cluster",
                   clusters_colours,
                   "Divisions by clusters - 2022 Federal Election")

```

After clustering, the regression models have been used to calculate a predicted outcome. Results have been transformed back to absolute values and then compared against actual and historical results. This is presented in figure \@ref(fig:electionresult), together with RMSE values in table \@ref(tab:2022rmse).

```{r electionresult, fig.cap="Comparison between prediction and election results"}
results$prediction_compared |>
  mutate(cluster=as.character(cluster)) |>
  mutate(across(any_of(c("Predicted","Actual")), ~ .x/100)) |>
  mutate(PartyAb=forcats::fct_relevel(PartyAb,party_cols)) |>
  ggplot(aes(x=Predicted,y=Actual,colour=cluster)) +
  geomtextpath::geom_textabline(slope=1,intercept = 0, label="0%",colour="gray50",linetype = 2,hjust=0.8,alpha=0.4) +
  geomtextpath::geom_textabline(slope=1,intercept = 0.05, label="5%",colour="orange",linetype = 2,hjust=0.8,alpha=0.4) +
  geomtextpath::geom_textabline(slope=1,intercept = -0.05, label="-5%",colour="orange",linetype = 2,hjust=0.8,alpha=0.4) +
  geomtextpath::geom_textabline(slope=1,intercept = 0.1, label="10%",colour="red",linetype = 2,hjust=0.8,alpha=0.4) +
  geomtextpath::geom_textabline(slope=1,intercept = -0.1, label="-10%",colour="red",linetype = 2,hjust=0.8,alpha=0.4) +
  geom_point(alpha=0.7) +
  facet_wrap(vars(PartyAb),ncol=2) +
  scale_colour_manual(values=clusters_colours) +
  scale_x_continuous(labels =  scales::label_percent()) +
  scale_y_continuous(labels =  scales::label_percent()) +
  labs(title="Election Forecast and Results compared")
```

```{r}
results$prediction_compared |>
  group_by(PartyAb,cluster) |>
  summarise(RMSE=sqrt(mean(Error^2,na.rm=TRUE))) |>
  bind_rows(
    results$prediction_compared |>
  group_by(cluster) |>
  summarise(RMSE=sqrt(mean(Error^2,na.rm=TRUE))) |>
  mutate(PartyAb="Overall")
  ) |>
  mutate(RMSE=round(RMSE,2)) |>
  arrange(cluster,PartyAb)   |>
  pivot_wider(names_from =PartyAb, values_from=RMSE)  |>
  select(all_of(c("cluster","Overall",party_cols)))   |>
  flex_default("RMSE Values for 2022 Forecast","2022rmse") |>
  theme_booktabs() |>
  align(j=1,align="center")
  
```

As expected, the results fail to adequately forecast primary voting, especially when it comes to Other parties and independents. However, it can be used as a tool to analyse the vote dynamics.

## The Teal Wave

A particular phenomenon of the last election consisted in the so-called "Teal Wave", where centrist independents campaigned in traditional Coalition electorates. Most of these electorates are located in inner-city, wealthy areas of Melbourne and Sydney, where voters have consistently voted Coalition since the Australian Federation. Right-leaning voters in these areas are perceived as moderate, socially liberal ("little-l liberals") who were dissatisfied with a perceived conservative turn in Coalition politics. Teal candidates managed to unseat incumbent MPs - did they in effect capture the dissatisfied Coalition base? The results and predictions for 4 cases are presented in figure \@ref(fig:tealsplot).

```{r tealsplot, fig.cap="Example 1: Teal Wave"}

warringah <- compare_results("Warringah",parties=4) 
wentworh <- compare_results("Wentworth",parties=4)
goldstein <- compare_results("Goldstein",parties=4)
kooyong <- compare_results("Kooyong",parties=4)

(warringah + wentworh) / (goldstein + kooyong) +  
  plot_layout(guides = 'collect') +
  plot_annotation(title="Teal voting in Melbourne and Sydney") +
  ggh4x::force_panelsizes(cols=12)

```

The answer in this case seems to indicate that the dwindling Coalition vote may not be entirely related to a new teal competitor. When comparing these results with demographic statistics from figure \@ref(fig:tealdemographics), these generational change is happening at the same pace or slower than the rest of Australia (shown by flat or growing differences in the Baby Boomer population). The same applies to the percentage of high earners. Nevertheless, the relatively low error in the prediction for the Coalition seems to indicate that the new independents managed to capture Labor and Green voters - likely of a "Labor Right" and "Blue Green" persuasion considering the areas' affluence - rather than attracting a dissatisfied Coalition base.

```{r}
dataset <- read_csv(path(project_path,"4. Data","consolidated.csv"))
clusters <- read_csv(path(project_path,"4. Data","clusters.csv"))         |>
            select(-any_of(c("Metro_Area")))

dataset <- dataset |>
           left_join(clusters,by=c("DivisionNm"="DivisionNm","election_year"="Year"))

rm(clusters)

nationals <- read_csv(path(project_path,"4. Data","cluster_values.csv")) |>
             pivot_longer(-c(Year,cluster),
                          names_to = "Attribute",values_to="National") |>
             mutate(Attribute=str_replace_all(Attribute," - ","_"),
                    Attribute=str_replace_all(Attribute,"-","_"),
                    Attribute=str_squish(Attribute),
                    Attribute=str_replace_all(Attribute," ","_")) 


demographic_data <- dataset |> 
        select(-all_of(party_cols)) |>
        select(-Metro_Area) |>
        select(-Metro,-StateAb,-election_year) |>
         pivot_longer(-c(DivisionNm,Year,cluster),
               names_to = "Attribute",values_to = "CED") |>
         mutate(Year=as.numeric(Year))                   |>
         left_join(nationals,
            by=c("Year","Attribute","cluster")) |>
          select(-cluster) |>
          mutate(Value=CED-National,.keep="unused") |>
          pivot_wider(names_from = Attribute, values_from = Value)

rm(dataset, nationals)

demographic_2021 <- read_csv(path(project_path,"4. Data","cluster_values_2021.csv")) |>
                     select(-Metro_Area, -cluster) |>
                     select(-Metro,-StateAb)

demographic_data <- demographic_data |>
                    filter(Year!=2021) |>
                    bind_rows(demographic_2021)

```

```{r tealdemographics, fig.cap="Selected demographics for teal seats"}

selected_demographics <- c("Age_Baby_Boomers","Age_Gen_Y","Income_2000_or_more","Religion_No_Religion_Secular")
electorates <- c("Warringah","Wentworth","Goldstein","Kooyong")

p <- list()
for(electorate in electorates){
p[[length(p)+1]] <- census_plot(demographic_data,
                                electorate,
                                selected_demographics) + 
                    paletteer::scale_color_paletteer_d("colRoz::uluru")
}

plot_grid(p,ncol=2,nrow=2,titletext = "Census attributes in teal seats")    
    
  
```

## The Green Wave {#green-wave}

Another feature of the past election was the increase in the number of Green Party MPs. In addition to the division of Melbourne, green candidates also won the seats of Griffith and Ryan in Brisbane. Again, do these victories have a demographic driver? Are there any differences between these electorates and contiguous divisions, and between them and other electorates where the Green have been strong contenders? \@ref(fig:greenvoting) shows the prediction of the latest and historic election results. figure \@ref(fig:green) presents selected demographic attributes for those areas.

```{r greenvoting, fig.cap="Green Voting"}

griffith <- compare_results("Griffith",parties=3) 
ryan     <- compare_results("Ryan",parties=3) 
brisbane    <- compare_results("Brisbane",parties=3) 
wills <- compare_results("Wills",parties=3) 

(griffith + ryan) / (brisbane + wills) +  
  plot_layout(guides = 'collect') +
  plot_annotation(title="Green Voting ")

```

```{r green, fig.cap="Demographics in Green strongholds"}

selected_demographics <- c("Age_Baby_Boomers",
                           "Religion_Catholic",
                           "Income_2000_or_more",
                           "Religion_No_Religion_Secular",
                           "Religion_Anglican_Uniting_Presbyterian")

electorates <- c("Griffith","Ryan","Brisbane","Wills")

p <- list()
for(electorate in electorates){
p[[length(p)+1]] <- census_plot(demographic_data,
                                electorate,
                                selected_demographics) + 
                    paletteer::scale_color_paletteer_d("colRoz::uluru")
}

plot_grid(p,ncol=2,nrow=2,titletext = "Census attributes selected in Green strongholds")   

```

All four cases show a similar story of continuous growth of the Green vote and progressive decline of Coalition and Labor polling results. However, there are two distinct dynamics at play. In three Queensland electorates (Griffith, Ryan and Brisbane) the Green's growth is sustained in a smaller percentage or older population, being replaced by a younger, wealthier, more secular electorate. In the Victorian seat of Wills, income growth is smaller, generational renewal is slower and although the rise in secularism is faster than average, the area used to have a very high concentration of Catholic followers (Northern suburbs of Melbourne being a popular area amongst post-war Italian migrants). These factors have given Labor a stronger hold in the area.

## The Changing Face of Suburbia

For a comparison outside inner city areas, let's compare four suburban electorates: Hasluck (Perth), Menzies (Melbourne), Fowler (Sydney) and Kingston (Adelaide). Their respective predictions and results are presented in figure \@ref(fig:suburbia1). A selection of key demographic variables is presented in figure \@ref(fig:suburbia2).

```{r suburbia1, fig.cap="Suburban Voting"}

hasluck <- compare_results("Hasluck",parties=3) 
menzies     <- compare_results("Menzies",parties=3) 
fowler    <- compare_results("Fowler",parties=3) 
kingston <- compare_results("Kingston",parties=3) 

(hasluck + menzies) / (fowler + kingston) +  
  plot_layout(guides = 'collect') +
  plot_annotation(title="Suburban electorates")

```

```{r suburbia2, fig.cap="Demographics in suburban seats"}

selected_demographics <- c("Age_Baby_Boomers",
                           "Language_South_Asian",
                           "Religion_Islam",
                           "Household_Standalone",
                           "Age_Gen_Y",
                           "Language_European")

electorates <- c("Hasluck","Menzies","Fowler","Kingston")

p <- list()
for(electorate in electorates){
p[[length(p)+1]] <- census_plot(demographic_data,
                                electorate,
                                selected_demographics) + 
                    paletteer::scale_color_paletteer_d("colRoz::virgo")
}

plot_grid(p,ncol=2,nrow=2,titletext = "Suburban electorates")    
    

```

From both figures, there are perhaps four different stories in these electorates:

-   In **Hasluck** (WA) [@hasluckresults], the changes have the top maybe be driven by generational renewal. The "Other" vote increase includes progressive independents and localist parties, which may have influenced the lower-than-predicted results for the Greens.
-   In **Menzies** (VIC) [@menziesresults], Coalition numbers decline influenced by generational change and a large decrease in the percentage of standalone houses. This abrupt change took place as an effect of the 2021 redistribution, where semi-rural areas moved into another electorate [@vicredist]. This a good example where the existing model was able to effectively predict the primary vote based on those demographic changes.
-   In **Fowler** (NSW) [@fowlerresults], an independent candidate altered Labor's trend. In these cases, a community-based candidate captured the multicultural vote from a "parachuted" Labor nominee - which is a variable not considered in the model. [@https://www.abc.net.au/news/catherine-hanrahan/79018522022]
- Although the predictions for **Kingston (SA) [@kingstonresults]**, are no far off the actual results, it seems more difficult to explain them in terms of demographic changes - it is worth noticing that the model for cluster 2 uses 17 different variables.

```{r}
rm(list=ls()[!(ls() %in% keep_vars)])
```

<!--chapter:end:05-results.Rmd-->

---
output:
  pdf_document: default
bibliography:
- book.bib
- packages.bib
---
# Conclusion {#conclusion}

In summary, this document presents an attempt to understand and explain changes in primary voting through the influence of the demographic composition of Australian federal electorates. Seeking easy interpretability, the approach involved the use of clustering to identify groups of electorates with similar composition, for which simple regularised regression models were developed with the aim of identifying the main demographic drivers of voting.

In general terms, the model presented in this document achieves the goal of identifying key demographic characteristics the affect primary voting for a particular political party. 

Although accuracy was not a key consideration, the model managed to produce moderately accurate results. Nevertheless, this could be improved by exploring the following:

* Further refining the segmentation into a recommender-type model, where not only similarity clusters are refined by other factors like State and degree of rurality are considered.
* Consider the introduction of longitudinality to account for the electorate's history and the influence of incumbency.
* Explore how to address the mismatch between election and census cycles to use the data from all the elections.
* Explore how federal and state elections influence each other.

Taking aside issues regarding the effectiveness of this model, it is also relevant to raise a note of caution about how to interpret the model correctly. By using demographic data is important to keep in mind that certain attributes must be interpreted as proxies of attitudes and values that have an effect on how voters choose. It is very important to make this distinction and avoid statements such as "Community XYZ votes/don't vote for Party A". This is definitely not an aim behind this exercise and it should not be interpreted this way.

Finally, it is also important to recognise that "all models are wrong but some are useful". Capturing and quantifying human behaviour can be a challenging task, but in this case, having a tool for analysis can prove value for parties, the media and the voters to check the accuracy of political narratives.

<!--chapter:end:06-discussion.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}
'`

<!--chapter:end:100-references.Rmd-->

