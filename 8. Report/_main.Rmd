--- 
title: "A Minimal Book Example"
author: "John Doe"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
# url: your book url like https://bookdown.org/yihui/bookdown
# cover-image: path to the social sharing image like images/cover.jpg
description: |
  This is a minimal example of using the bookdown package to write a book.
  The HTML output format for this example is bookdown::gitbook,
  set in the _output.yml file.
link-citations: yes
github-repo: rstudio/bookdown-demo
---

# Acknowledgements



```{r eval=FALSE}
bookdown::serve_book()
bookdown::render_book("index.Rmd", "bookdown::pdf_book")

```


```{r eval=FALSE, include=FALSE}

library(tidyverse)
library(auspol)
library(aussiemaps)
library(auscensus)

# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown',"tigris","cropgrowdata"
), 'packages.bib')
```


<!--chapter:end:index.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---
# Introduction {#intro}

# Strucure
_ Problem statement
- Obtaining the data
- EDA
- Modelling
- Conclusions

APPENDICES
- HOW we waht the data obtained
- Detailed EDa
- TEchnical note on buulding packages
- vignettes



# Cross-references {#cross}

Cross-references make it easier for your readers to find and link to elements in your book.

## Chapters and sub-chapters

There are two steps to cross-reference any heading:

1. Label the heading: `# Hello world {#nice-label}`. 
    - Leave the label off if you like the automated heading generated based on your heading title: for example, `# Hello world` = `# Hello world {#hello-world}`.
    - To label an un-numbered heading, use: `# Hello world {-#nice-label}` or `{# Hello world .unnumbered}`.

1. Next, reference the labeled heading anywhere in the text using `\@ref(nice-label)`; for example, please see Chapter \@ref(cross). 
    - If you prefer text as the link instead of a numbered reference use: [any text you want can go here](#cross).

## Captioned figures and tables

Figures and tables *with captions* can also be cross-referenced from elsewhere in your book using `\@ref(fig:chunk-label)` and `\@ref(tab:chunk-label)`, respectively.

See Figure \@ref(fig:nice-fig).

```{r nice-fig, fig.cap='Here is a nice figure!', out.width='80%', fig.asp=.75, fig.align='center', fig.alt='Plot with connected points showing that vapor pressure of mercury increases exponentially as temperature increases.'}
par(mar = c(4, 4, .1, .1))
plot(pressure, type = 'b', pch = 19)
```

Don't miss Table \@ref(tab:nice-tab).

```{r nice-tab, tidy=FALSE}
knitr::kable(
  head(pressure, 10), caption = 'Here is a nice table!',
  booktabs = TRUE
)
```

# Parts

You can add parts to organize one or more book chapters together. Parts can be inserted at the top of an .Rmd file, before the first-level chapter heading in that same file. 

Add a numbered part: `# (PART) Act one {-}` (followed by `# A chapter`)

Add an unnumbered part: `# (PART\*) Act one {-}` (followed by `# A chapter`)

Add an appendix as a special kind of un-numbered part: `# (APPENDIX) Other stuff {-}` (followed by `# A chapter`). Chapters in an appendix are prepended with letters instead of numbers.



# Footnotes and citations 

## Footnotes

Footnotes are put inside the square brackets after a caret `^[]`. Like this one ^[This is a footnote.]. 

## Citations

Reference items in your bibliography file(s) using `@key`.

For example, we are using the **bookdown** package [@R-bookdown] (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and **knitr** [@xie2015] (this citation was added manually in an external file book.bib). 
Note that the `.bib` files need to be listed in the index.Rmd with the YAML `bibliography` key.


The RStudio Visual Markdown Editor can also make it easier to insert citations: <https://rstudio.github.io/visual-markdown-editing/#/citations>


# Blocks

## Equations

Here is an equation.

\begin{equation} 
  f\left(k\right) = \binom{n}{k} p^k\left(1-p\right)^{n-k}
  (\#eq:binom)
\end{equation} 

You may refer to using `\@ref(eq:binom)`, like see Equation \@ref(eq:binom).


## Theorems and proofs

Labeled theorems can be referenced in text using `\@ref(thm:tri)`, for example, check out this smart theorem \@ref(thm:tri).

::: {.theorem #tri}
For a right triangle, if $c$ denotes the *length* of the hypotenuse
and $a$ and $b$ denote the lengths of the **other** two sides, we have
$$a^2 + b^2 = c^2$$
:::

Read more here <https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html>.

## Callout blocks


The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html


# Sharing your book

## Publishing

HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html

## 404 pages

By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you'd like to customize your 404 page instead of using the default, you may add either a `_404.Rmd` or `_404.md` file to your project root and use code and/or Markdown syntax.

## Metadata for sharing

Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the `index.Rmd` YAML. To setup, set the `url` for your book and the path to your `cover-image` file. Your book's `title` and `description` are also used.



This `gitbook` uses the same social sharing data across all chapters in your book- all links shared will look the same.

Specify your book's source repository on GitHub using the `edit` key under the configuration options in the `_output.yml` file, which allows users to suggest an edit by linking to a chapter's source file. 

Read more about the features of this output format here:

https://pkgs.rstudio.com/bookdown/reference/gitbook.html

Or use:

```{r eval=FALSE}
?bookdown::gitbook
```


`r if (knitr::is_html_output()) '
# References {-}
'`


<!--chapter:end:01-intro.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---
# Sourcing Data {#data}

Based on the previously explained approach, data had to be source from 2 main sources:

- The Australian Electoral Commission (AEC). The AEC contains detailed online records for all federal election held in the 21st century, through their Tally Room websites. All data is presented in CSV format and it is publicly and easily accessible.

- The Australian Bureau of Statistics (ABS). The ABS provides an extensive repository of statistical data. This project is using Census Data, which is available through their Census Data packs.

In both cases, the data provided is of high quality, trustable and provided in open formats. However, three particular challenges arose:

- There is a large volume of data: multiple political parties, +100 electoral divisions and a very large number of statistical data collected in each census.
- Not all publicly available Census data is provided by electoral division. Aggregation from statistical collection areas into electorates is not straightforward due to a lack of 1:1 correspondence between the former (defined by the AEC) and the latter (defined by the ABS).
- Despite the best efforts of both organisations, names of electorates, parties, census attributes change over time, requiring work to track a variable across time.

To better overcome those challenges in a repeatable way, three R packages have been created as part of this projects, namely:

- {auspol}, which extracts and presents electoral results.
- {auscensus}, which allows to interact with Census Data Packs to extract different statistics across geographical units, and across censuses.
- {aussiemaps}, which assists with aggregating census data into electoral divisions, by matching and apportioning different geographical structures.

Each package is further detailed in the appendix.

Using the above tools, the extraction pipeline can be represented by figure \@ref(fig:data-flow).

```{r data-flow, fig.cap="Flow of data from sources to dataset", echo=FALSE}
library(DiagrammeR)
library(here)
DiagrammeR::grViz(here("img","02_data_flow.gv"))
```

The main points of the process are explained below.


## Extracting data

`r if (knitr::is_html_output()) '
# References {-}
'`


<!--chapter:end:03-sourcing-and-processsing-data.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}
'`

<!--chapter:end:100-references.Rmd-->

---
bibliography: references.bib
---

# (APPENDIX) Extracting Data

A particular challenge for this project was to efficiently and systematically being able to extract data. In this particular case, data sources are public and freely made available by Australian government departments. However, there were two challenging aspects, namely:

-   The volume of data, especially when it comes to Census Data. This also presented a challenge in terms of selection and aggregation of data not presented at electorate level.
-   Changes in file structure and naming convention across time, having to standardise variable names across different census and election years.

The search for existing data packages did not produce satisfactory results - only a package to retrieve historical weather data was found ([{cropgrowdays}](https://gitlab.com/petebaker/cropgrowdays/)[@cropgrowdays]). Therefore, as par of this project it was necessary to create the following R packages:

-   {auspol}, a data package with containing voting tallies for the Australian House of Representatives. This package contains processed data, sourced from the Australian Electoral Commission, as well as functions to access and plot them. In addition to primary votes (the scope for this project), this also contains preferential distribution tallies.

-   {auscensus}, a package to interact with Census Data Packs (as published by the Australian Bureau of Statistics, ABS). This package does not contain the actual data - each data pack ranges from 600 to 800 MB.

-   {aussiemaps}, which is a rewriting of a geospatial package experiment by the author. This package contains geographical boundaries for ABS statistical structures as well as non-ABS geographies such as electoral divisions. In this project, this package is use to aggregate data from granular statistical structures to electorates.

## Package Architecture

The three packages have been designed using the same approach, which can be summarised by the following:

-  Data is not included in the packages, but hosted on GitHub repositories. Given the large size of the data files, they cannot be directly included along code and they are shared "releases"instead. Then, the package functions download data as needed. This applies for metadata for the three packages and the actual data for {auspol} and {aussiemaps}.

<!--chapter:end:70-ExtractingData.Rmd-->

# (APPENDIX) {auscensus} Vignette
*Extracted from https://gh.carlosyanez.id.au/auscensus/articles/complex_case.html on Sunday 22 January 2023*

```{r}
library(auscensus)
library(tidyverse)
```


This vignette shows a more complex use case of auscensus. Let's assume we want to extract the percentage of Australian Citizens for all Commonwealth Electoral Divisions, as measured in last 4 Censuses (2006-2021).

An initial exploration shows that this data can be found in table 01 (across all four censuses) - which provided an statistical summary. However, is not published aggregated by electorate across all censuses.


```{r}

#| eval: true

census_tables <- list_census_tables() 

census_tables <- census_tables |>
                 filter(if_any(any_of(c("Number")),~ .x %in% c("01"))) 

tables_summary <- census_tables |>
                  select(-contains("Table")) |>
                  pivot_longer(-Number, names_to="Year",values_to = "Value") |>
                  filter(!is.na(Value)) |>
                  select(-Value)


list_census_geo_tables(year = tables_summary$Year,geo="CED|CED_2007|CED_2004",table_number = tables_summary$Number) |>
  mutate(Year=as.character(Year)) |>
  right_join(tables_summary, by=c("table_number"="Number","Year"="Year"))

```


Therefore, we will retrieve the data from the lowest statistical unit. However, SA1 were not available in 2006 - where the smallest area was a "CD".

```{r}

#| eval: true

list_census_geo_tables(year = tables_summary$Year,geo=c("SA1|CD"),table_number = tables_summary$Number) |>
   mutate(Year=as.character(Year)) |>
  right_join(tables_summary, by=c("table_number"="Number","Year"="Year")) 


```

The next step is to figure the attributes for the numbers of Australian citizen and total population, which are presented below:


```{r}

citizenship_attributes <- tibble()

for(i in 1:nrow(tables_summary)){

  table_i <- tables_summary[i,]$Number
  year_i  <- tables_summary[i,]$Year

  attr_i <- list_census_attributes(table_i) |> 
             pivot_longer(-c(Table,Attribute),
                           names_to="Year",values_to = "Value") |>
              filter(Year==year_i) |>
              filter(!is.na(Value)) |>
              select(-Value)

  citizenship_attributes <- bind_rows(attr_i,citizenship_attributes)

}



citizenship_attributes |>
  head()

```

```{r}

citizenship_attributes <- citizenship_attributes   |> 
                       distinct(Attribute,Year) |>
                      filter(str_detect(Attribute,"[Aa]ustralian")) |>
                      filter(str_detect(Attribute,"[Pp]erson")) |>
                      mutate(dummy=TRUE) |>
                      pivot_wider(names_from = Year, values_from = dummy)  |>
                      bind_rows(
                         citizenship_attributes   |> 
                       distinct(Attribute,Year) |>
                      filter(str_detect(Attribute,"^[Tt]otal")) |>
                      filter(str_detect(Attribute,"[Pp]ersons$")) |>
                      mutate(dummy=TRUE) |>
                      pivot_wider(names_from = Year, values_from = dummy)
                      )


citizenship_attributes 
```

Using *attribute_tibble_to_list*, this data frame can be converted into the required format.

```{r}

citizenship_attributes <- citizenship_attributes |>
                          select(Attribute)      |>
                          mutate(AttrNew = case_when(
                            str_detect(Attribute,"Australian") ~ "Australian Citizens",
                            str_detect(Attribute,"Total")      ~ "Total"
                          ))

levels <- attribute_tibble_to_list(citizenship_attributes)
```


Now,  we can cycle through the four censuses and extract the data. Please note that CDs and SA1s are not equivalent, but they are stored together for convenience:


```{r}
census_years <- c("2006","2011","2016","2021")

citizenship <- tibble()

for(year in census_years){

  if(year=="2006"){
    geo_structure_x <- "CD"
  } else{
    geo_structure_x <- "SA1"
  }

  citizenship_i <- get_census_summary(census_table = census_tables,
                                   selected_years = year,
                                   geo_structure=geo_structure_x,
                                   attribute = levels) 


  citizenship <- bind_rows(citizenship,citizenship_i)


}

rm(citizenship_i,geo_structure_x,levels,citizenship_attributes)



```


To aggregate the data,  **[aussiemaps::geo_aggregate()](https://gh.carlosyanez.id.au/aussiemaps/)** can help using area to apportion on non-overalpping cases. Then, this package's *calculate_percentage()* will take the totals from the list and calculate percentages.


```{r}

citizenship_ced<- tibble()
codes <- c("CD_CODE_2006","SA1_7DIGITCODE_2011","SA1_7DIGITCODE_2016","SA1_CODE_2021")
ceds  <- c("CED_NAME_2006","CED_NAME_2011","CED_NAME_2016","CED_NAME_2021")

 for(i in 1:length(census_years)){

   year <- as.double(census_years[i])

   value_i <- citizenship |> 
                  filter(Year==year)     |>
                  select(-Unit)                    |>
                  rename(!!codes[i]:="Census_Code") |>
                  collect() |>
                  aussiemaps::geo_aggregate(
                              values_col="Value",
                              original_geo=codes[i],
                              new_geo=ceds[i],
                              grouping_col = c("Year","Attribute"),
                              year=census_years[i]) |>
              rename("Unit"=ceds[i])  |>
              filter(!is.na(Unit))    |>
              filter(str_detect(Unit,"[Ss]hipping",TRUE))|>
              filter(str_detect(Unit,"[Uu]sual",TRUE))   |>
              filter(str_detect(Unit,"[Aa]pplicable",TRUE)) 


    value_i <- value_i  |> 
               auscensus::calculate_percentage(key_col = "Attribute",
                                                value_col = "Value",
                                                key_value = "Total",
                                                percentage_scale = 100)

   citizenship_ced <- bind_rows(citizenship_ced,value_i)


 }


citizenship_ced 

```

<!--chapter:end:81-auscensus.Rmd-->

# (APPENDIX) {auspol} Vignette
*Extracted from https://gh.carlosyanez.id.au/auspol/articles/house_primary_vote.html on Sunday 22 January 2023*
```{r}
library(auspol)
library(tidyverse)
```


**auspol** includes two functions to interact with the preference distribution data:

- get_house_primary_vote()
- house_primary_vote_summary()
- house_primary_comparison_plot()
- house_primary_historic_plot()

## What is this?

If you are unfamiliar with the Australian electoral system and preferential voting, please look at this [explainer(https://www.aec.gov.au/learn/preferential-voting.html) before proceeding.

## Getting the data

*get_house_primary_vote()* is the basic function to retrieve primary vote data published by the AEC. Without any arguments, it will deliver all the results for all elections, but it comes with parameters to facilitate filtering.
For instance, to get the results for Brisbane for 2022:

```{r}
get_house_primary_vote(division="Brisbane",year=2022)
```

Both parameters can include more than one value, e.g.

```{r}
get_house_primary_vote(division="Brisbane",year=c(2019,2022))
```

```{r}
get_house_primary_vote(division=c("Brisbane","Perth"),year=c(2019,2022))
```

By default, the results are presented by polling place, with the possibility to aggregate them.

```{r}
get_house_primary_vote(division=c("Brisbane","Perth"),year=c(2019,2022),aggregation = TRUE)
```

```{r}
get_house_primary_vote(division=c("Brisbane","Perth"),year=c(2019,2022), polling_places = c("Yokine North"))
```

It is also possible to restrict the results to selected polling places



Additionally, it is possible to select one or more states instead of a group of divisions, e.g.:

```{r}
get_house_primary_vote(state=c("TAS"),year=c(2019,2022),aggregation = TRUE)
```

It is also possible to filter results by one or more parties:

```{r}
get_house_primary_vote(state=c("NT"),year=c(2019,2022),aggregation = TRUE, party_abb=c("ALP","CLP"))

```

*house_primary_vote_summary()* builds on the basic function and summarises data
.
```{r}
house_primary_vote_summary(division = "Brisbane", year=2022)
```

Using the previous filters,  it is possible to get ad-hoc summaries, for instance - all the ALP votes in Queensland in 2022, or the historic Liberal vote in Franklin.

```{r}

house_primary_vote_summary(state = "QLD", year=2022,parties="ALP")

```



```{r}
house_primary_vote_summary(division="Franklin",parties="LP")
```

## Plotting 

### Historic Trends

The first plotting convenience function in this package allows comparing the evolution of primary voting across time. This function relies on house_primary_summary and uses many of its options. Its first use is to represent party trends in one electorate:

```{r primvote1}
house_primary_historic_plot("Canberra")
```

As they can be many minor parties, it is sometimes useful just to focus on a number of parties. This function allows filtering by a number of parties or by filtering by the most voted in a certain year. In both cases, it is possible to consolidate others' votes.



```{r primvote2}
house_primary_historic_plot("Canberra", parties =3, 
                            parties_year = 2022, 
                            include_others = TRUE )

```

Finally, it is possible to aggregate party acronyms - sometimes the same party has changed named or registered differently

```{r primvote3}

house_primary_historic_plot(division="Brisbane",parties=5,
                            merge_parties = list(LNP=c("LNP","LNQ","LP"),
                                                 ON=c("HAN","ON"))) 

```

## Results for one election

This package also contains a convenience function to look at the primary vote results for one division. Lile the previous function, this also inherits many of the attributes of *get_house_primary_vote*.

```{r primvote4}
house_primary_comparison_plot(division = "Kooyong", year=2022,individualise_IND = TRUE)

```

The plots can also be displayed using bars, as shown below

```{r primvote5}
house_primary_comparison_plot(state="TAS",year=2022,parties=c("LP"),plot_format = "bar")
```

<!--chapter:end:82-auspol.Rmd-->

# (APPENDIX) {aussiemaps} Vignette
*Extracted from https://gh.carlosyanez.id.au/aussiemaps/articles/aussiemaps.html on Sunday 22 January 2023*
```{r}
library(aussiemaps)
library(tidyverse)
```


## {aussiemaps} - Yet another maps package

This package has been built to facilitate the use of the geographic boundary files published by the Australian Bureau of Statistics (ABS). The ABS has published several boundary files - i.e. the [Australian Statistical Geography Standard (ASGS)](https://www.abs.gov.au/statistics/statistical-geography/australian-statistical-geography-standard-asgs) from 2006 onwards and the  [Australian Standard Geographical Classification (ASGC)](https://www.abs.gov.au/AUSSTATS/abs@.nsf/Latestproducts/DEDA554E1B6BB78BCA25791F000EEA26) before that - covering both:

-   Statistical Geographic Structures created and maintained by the ABS - and used to collect data.
-   Non-ABS structure, e.g Postal Areas, Electoral Divisions, LGA boundaries.

This package has four versions of the above, aligned with Census years 2006, 2011,2016 and 2021. This makes it easy to mix use with Census data packs or the {auscensus} package.

This package provides access to a processed version of those boundaries - as sf objects, allowing it to cater for the following scenarios:

* Get the boundaries of an electoral division across time.
* Get all the S1 or S1 areas within a Council area.
* Get all postcodes in a state or territory.

This repository also contains the R script used to process the files. Although not tested, the functions could also accommodate BYO structures for other years.

## Getting started.

The core function of this package is get_map(), which retrieves the sf files. get_map provides several filters to narrow down the data retrieved and avoid getting everything unless is needed. The key parameters for this function are:

- How the data will be filtered (e.g. return only objects in a particular state, council or metro area)
- Which year/version of the data will be retrieved?
- Which aggregation will be used (e.g. which will be the resulting objects)



Filters and column names follow the same name convention used in the original ABS files. The function list_attributes(), will present them in tibble format:

```{r}
list_attributes() |>
  head(10)
```

Let's say we want to retrieve all SA1 in the City of Melbourne for 2016 - this can be done via:

```{r}
melbourne_sa1 <- get_map(filters=list(LGA_NAME_2016=c("Melbourne")),
                         year=2016,
                         aggregation = c("SA1_MAINCODE_2016"))

#just an empty plot

melbourne_sa1 |>
  ggplot()+
  geom_sf(fill="azure1") +
  theme_void() +
  labs(title="SA1s in the City of Melbourne")

```

## Filtering via regular expressions

The filter arguments are intended to be regular expressions, for instance:

```{r}

preston <- get_map(filters=list(SSC_NAME_2016=c("Preston")),
                         year=2016,
                         aggregation = c("SSC_NAME_2016"))

preston |>
  select(SSC_NAME_2016,UCL_NAME_2016,STE_NAME_2016)

```

Whereas

```{r}
prestons <- get_map(filters=list(SSC_NAME_2016=c("^Pres"),
                                 STE_NAME_2016=c("Wales","^T")
                                 ),
                         year=2016,
                         aggregation = c("SSC_NAME_2016"))

prestons |>
  select(SSC_NAME_2016,UCL_NAME_2016,STE_NAME_2016)

```

## Even more complex filtering

If more complex subsetting is needed, it is possible to pass a table with the elements to be selected. In order to do that, list_structure() comes to help. This function uses the same year and filters parameters than get_map() (actually this function calls the former if no table is provided). Once you have the dataset, you can use any ad-hoc filter to get the needed structures. For example

```{r}

greater_sydney <- list_structure(year=2021,filters=list(GCCSA_NAME_2021="Greater Sydney"))

#use_cache option stores the results/reuses pre-processed results
sydney_area <- get_map(filter_table = greater_sydney,
                       year=2021,
                       aggregation = "GCCSA_NAME_2021",
                       use_cache = TRUE) 

#outline

# all suburbs starting wit A
suburbs_a_filter <- greater_sydney |>
                    filter(str_detect(SAL_NAME_2021,"^A"))

suburbs_a  <- get_map(filter_table = suburbs_a_filter,
                       year=2021,
                       aggregation = "SAL_NAME_2021") |>
                mutate(border="orange",fill="orange")


ggplot() +
  geom_sf(data=sydney_area,fill="white",colour="black")+
  geom_sf(data=suburbs_a,fill="orange") +
  labs(title="Suburbs starting with A - Sydney") +
  theme_void()

```

## Aggregation

It is worth noticing that the *aggregation* parameter accepts more than one variable. Those parameters are passed to dplyr::group_by() before aggregation - thus more variables will impact how sf objects are aggregated. For instance, if we look at the postal areas (ABS approximation of a postcode) in the cities of Melbourne and Port Phillip:

```{r}

poas_inner_melbourne <- get_map(filters=list(LGA_NAME_2022=c("Melbourne","Phillip$")),
                                year=2021,
                                aggregation = c("POA_NAME_2021","LGA_NAME_2022"))

poas_inner_melbourne |>
  mutate(colour=case_when(
    POA_NAME_2021=="3004" ~ "orange",
    TRUE ~ "grey"
  )) |>
  ggplot()+
  geom_sf(aes(fill=colour,colour=LGA_NAME_2022)) +
  scale_fill_identity() +
  theme_void() +
  labs(title="Postcode 3004 extends across two LGAs")

```
## Using external data

 This package provides sf data, thus the result can be easily merged with any other data frame. Since data has been taken from the ABS and the output contains both names and **codes** of geographic structures, data can be joined using an un-ambiguous key. Furthermore, with {auscensus}, this package can be used as data filters to retrieve said data in the first place. For example:
 
```{r}

# Chileans by Commonwealth Electoral Divisions in Metropolitan Brisbane, 2021

attr <- list_structure(year=2021,filters=list(GCCSA_NAME_2021=c("Brisbane"))) |>
        distinct(CED_NAME_2021)

chileans <- auscensus::get_census_summary(table_number= "09",
                                          selected_years = "2021",
                                          geo_structure = "CED",
                                          geo_unit_names =   attr$CED_NAME_2021,
                                          attribute = list(Chileans=c("Persons_chile_total")),
                                          reference_total = list(Total=c("Persons_total_total")),
                                          percentage_scale =100)

brisbane_ced <- get_map(filters = list(GCCSA_NAME_2021=c("Brisbane")),
                        year = 2021,
                        aggregation = c("CED_NAME_2021"),
                        use_cache = TRUE)

chileans$Value

brisbane_ced |>
  left_join(chileans,by=c("CED_NAME_2021"="Unit")) |>
  ggplot(aes(fill=Value,colour=Value)) +
  geom_sf() +
  scale_fill_continuous()+
  labs(title="Chileans in Bribane's Federal Electorates") +
  theme_void()
  

```
 
## Data Aggregation

As a bonus function, *geo_aggregate()*  aggregates data, transforming between geographic structures. For instance, let's imagine that for the previous case, it is only possible to get data by SA2. *geo_aggregate()* can aggregate the data to obtain an approximation for each electorate. When an SA1 is not fully contained by an electorate, the function will use the overlapping area as the weighting factor.

```{r}

attr <- list_structure(year=2021,filters=list(GCCSA_NAME_2021=c("Brisbane"))) |>
        distinct(SA2_CODE_2021)

chileans_sa2 <- auscensus::get_census_summary(table_number= "09",
                                          selected_years = "2021",
                                          geo_structure = "SA2",
                                          geo_unit_codes =     attr$SA2_CODE_2021,
                                          attribute = list(Chileans=c("Persons_chile_total"))) |>
                  rename("SA2_CODE_2021"="Census_Code")

# please note these Electoral divisions are not built from SA2s - proportional allocation will result in factional 
# Therefore - This is an approximation
chileans <- geo_aggregate(original_data = chileans_sa2,
                          values_col = "Value",
                          original_geo = "SA2_CODE_2021",
                          new_geo      = "CED_NAME_2021",
                          grouping_col =   c("Year","Attribute"),
                          year=2021) |>
            rename("Unit"="CED_NAME_2021")



brisbane_ced |>
  left_join(chileans,by=c("CED_NAME_2021"="Unit")) |>
  ggplot(aes(fill=Value,colour=Value)) +
  geom_sf() +
  scale_fill_continuous()+
  labs(title="Chileans in Bribane's Federal Electorates") +
  theme_void()

```

<!--chapter:end:83-aussiemaps.Rmd-->

