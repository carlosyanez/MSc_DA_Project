--- 
title: "Analysing Australian Election Results"
author: "Carlos Yanez Santibanez"
date: "`r Sys.Date()`"
output: pdf_document
documentclass: book
bibliography:
- book.bib
- packages.bib
link-citations: yes
github-repo: "carlosyanez/MSc_Project"
site: bookdown::bookdown_site
---

# Acknowledgements



```{r eval=FALSE, include=FALSE}
#bookdown::serve_book()
bookdown::render_book("index.Rmd", "bookdown::pdf_book")

```



<!--chapter:end:index.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---
# Introduction {#intro}

# Strucure
_ Problem statement
- Obtaining the data
- EDA
- Modelling
- Conclusions

APPENDICES
- HOW we waht the data obtained
- Detailed EDa
- TEchnical note on buulding packages
- vignettes


`r if (knitr::is_html_output()) '
# References {-}
'`


<!--chapter:end:01-intro.Rmd-->

---
output:
  pdf_document: default
  html_document: default
bibliography:
- book.bib
- packages.bib
---

```{r seven-setup,message=FALSE,warning=FALSE,echo=FALSE}
library(DiagrammeR)
library(dplyr)
library(readr)
library(stringr)
library(here)
library(auspol)
library(flextable)
library(ggplot2)

source(here::here("formatting_defaults.R"))

project_path <- fs::path(here(),"..")


```

# Data {#data}

## Data Sources {#data-sources}

The first in the process was to source demographic and electoral data, which has been provided from two sources:

-   **The Australian Electoral Commission** (AEC) [@AEC] . The AEC contains detailed online records for every federal election held in the 21st century, through their Tally Room website [@TallyRoom].

-   The **Australian Bureau of Statistics** (ABS) [@ABS]. The ABS provides a wide number of national statistics and is responsible to conduct a national census of population and housing every 5 years. Comprehensive census data is provided in multiple formats, including csv files through Census Data Packs [@CensusDataPack], which are available for censuses from 2006 onwards.

Both organisations are the authoritative source for electoral and statistical data in Australia, and the data is provided openly. Although there are no quality issues, the way that data is provided presents other challenges, namely:

-   In both cases, data are provided in large volumes and exhaustive granularity. If not done effectively, data extraction and aggregation can be time-consuming and resource intensive.
-   Census data points are provided using the ABS own geographical standard - and only a small selection of census data is provided at the electoral division level. Conversion between ABS geographical structures and electoral divisions is not straightforward as there is no 1:1 correspondence. Both geographical systems change from election to election and census to census.
-   Despite the best efforts of both organisations in keeping consistency, names of electorates, parties, and census attributes change over time - to compare similar statistics manual mapping is necessary.

To address these issues and ensure repeatability, three R packages have been written to undertake this task:

-   **{auspol} [@R-auspol]**, which extracts and presents electoral results.
-   **{auscensus} [@R-auscensus]**, which allows to interact with Census Data Packs to extract different statistics across geographical units, and across censuses.
-   **{aussiemaps} [@R-aussiemaps]**, which assists with aggregating census data into electoral divisions, by matching and apportioning different geographical structures.

The appendix contains a vignette for each package, explaining their respective *modus operandi*. At a higher level, the extraction pipeline for this project is represented by figure \@ref(fig:data-flow).

```{r data-flow, fig.cap="Flow of data from sources to dataset", echo=FALSE}
DiagrammeR::grViz(here("img","02_data_flow.gv"))
```

In summary, the process followed consisted of the below steps:

1.  Census data was extracted from the respective Census Data Pack using **{auscensus}**. Using the package workflow, key attributes were identified in each census, extracted from the respective files and given common names. Data were extracted for statistical areas and apportioned into Commonwealth Electoral Divisions by overlapping area, with the help of functions written into **{aussiemaps}**

2.  Primary vote results for each division were extracted using the **auspol** package.

3.  All the data was stored in a local database, from where was extracted and put together in a single dataset.

4.  From there, the "raw" data was further processed and stored in a single "consolidated" dataset.

## Data Selection {#data-selection}

### Census and Election Years {#data-selection-years}

The first to address when extracting the data is to establish a correspondence between census and election data. Since election the census cycle (5 years) does not match the electoral cycle (determined by the incumbent government, with a 3-year term for the House of Representatives), there is a potential problem of the census data not being completely representative of the population on a given election day. Figure \@ref(fig:electionsandcensus) presents the best matches between both events held in the 21st century.

```{r electionsandcensus}
 tibble::tribble(~Year, ~Event,
                2001,"Census",
                2006,"Census",
                2011,"Census",
                2016,"Census",
                2021,"Census",
                2001,"Election",
                2004,"Election",
                2007,"Election",
                2010,"Election",
                2013,"Election",
                2016,"Election",
                2019,"Election",
                2022,"Election"
                ) |>
  mutate(start = lubridate::ymd(Year,truncated = 2L),
         end=start+lubridate::ddays(365)) |>
vistime::gg_vistime(col.event="Year",col.group = "Event", title = "Timeline of Census and Elections") 

```

Considering the census data available and selecting the elections closer to each census, four pairs of events were selected for data extraction. there are presented in table \@ref(tab:selected-pairs)

```{r }

tibble::tribble(~Census,~Election,
                "2006","2007",
                "2010","2011",
                "2016","2016",
                "2021","2022") |>
   flex_default("Selected Census-Election pairings","selected-pairs") |>
   set_table_properties( width = .8, layout = "autofit") |>
   align(j=1, align = "right", part = "all")


```

Please note that this selection will remove half of the elections within the period, which may have an effect on model accuracy. However, since the objective is not to obtain an accurate prediction this has been accepted as a trade-off to avoid having to interpolate demographic attributes between censuses - which is also subject to inaccuracies given the rapid demographic changes experienced in Australia's main cities.

### Electoral Data {#data-selection-electoral}

In the case of the electoral data. not much processing was required. The source data already contains records of primary voting for each electorate and only percentages have been calculated. In addition, the number of total votes per party at the national and state level have been calculated. A sample of the extracted data is presented in table \@ref(tab:canberra2022).

```{r}

auspol::house_primary_vote_summary(division="Canberra",
                                   year=2022,
                                   parties = c("ALP","LP","GRN"),
                                   include_others = TRUE) |>
  mutate(Year=as.character(Year)) |>
  mutate(PartyNm=case_when(
    PartyAb =="Other" ~ "Other Parties",
    PartyAb =="LP" ~ glue::glue("{PartyNm} (Coalition)"),
    TRUE ~ PartyAb
  ),
  PartyAb = case_when(
    stringr::str_detect(PartyNm,"Coalition") ~"COAL",
    TRUE ~ PartyAb
  )) |>
  mutate(Percentage=OrdinaryVotes/sum(OrdinaryVotes)) |>
  select(Year=Year,
         Division=DivisionNm,
        Abbreviation=PartyAb,
        Party=PartyNm,
        Votes=OrdinaryVotes,
        Percentage=Percentage) |>
  flex_default("Sample extraction - Canberra 2022","canberra2022") |>
    set_formatter( Percentage = function(x) sprintf( "%.1f%%", x*100 ) )


```

### Census Data

As mentioned in section \@ref(data-sources), a major challenge with respect of census data is the large volume of data points collected. For instance, the data pack for the 2022 Census contains 62 different tables, ranging from 8 [^04-data-1] to 1,590 [^04-data-2] attributes.

[^04-data-1]: *02 -Selected Medians and Averages*

[^04-data-2]: *09 - Country of Birth of Person by Age by Sex*

To select which variables to extract, literature and journalistic sources were consulted ([@biddle2022], [@votingpatternsbygen], [@jakubowicz]) to inform an initial set of covariates. In total (XYZ) variables were selected, which correspond to below to the following groups:

1.  **Income** : Distribution of population in pre-set income brackets.

2.  **Education Level**: Distribution of educational achievement (from incomplete secondary to vocational education and academic degrees).

3.  **Age**: Distribution of the population in generational cohorts. Taking into account the selected elections, the four groups of interest are Baby Boomers (1946 to 1964), Generation X (1965 to 1980), Generation Y (1981 to 1996) and Generation Z (1997 to 2021).

4.  **Relationship status**: Variables describing civil status (e.g. living alone, married, in a de facto relationship).

5.  **Household type:** Descriptors of type of housing , (e.g. standalone house, semi-detached, flats).

6.  **Household tenure:** Descriptors of house ownership, rental or other arrangement (e.g. public housing).

7.  **Citizenship**: Percentage of the population that hold Australian citizenship. Although non-citizens are not entitled to vote, this variable can be taken as a proxy for relative integration of migrant communities into civic life.

8.  **Religion:** Percentage of the population declaring to profess a religion. For this analysis, largest and high growth religious groups were selected (No religion/secular, Roman Catholic, Anglican-Presbyterian-Uniting, Christian Orthodox, Other Christianity, Islam, Hinduism, Buddhism).

9.  **Language**: Languages spoken in the community. Similar to religion, a selection of relevant language have been included to reflect the historic and current migrant communities.

Apart from those, each electorate has been classified as **metropolitan** if it lies within the boundaries of Australian capital cities or **non-metropolitan** if not. Altogether, these variables try to reflect wealth and education (cited by [@biddle2022] as key factors in deciding political persuasion), as well as stage in life and belonging to a particular migrant community (sometimes cited as an influential factor, for instance in [@jakubowicza]).

A sample of the resulting dataset is present in table \@ref(tab:datasetsample).


```{r include=FALSE}
dataset <- read_csv(fs::path(project_path,"4. Data","consolidated.csv"))

```

```{r}
dataset |> 
  slice_sample(n=8) |>
  select(election_year,DivisionNm,ALP,COAL,GRN,Other,
         Australian_Citizens,Age_Baby_Boomers,Age_Gen_X,
         Language_Chinese,Language_Greek) |>
  mutate(election_year=as.character(election_year)) |>
  mutate(across(where(is.numeric),~round(.x,2))) |>
  flex_default("Dataset sample","datasetsample") |>
  rotate(rotation="btlr",align="bottom", part = "header") |>
  autofit()

```

## Data Exploration {#eda}

In total, the resulting dataset is made up of 4 response variables and 55 potential predictors, plus identificatory attributes like division mane and election year. As expected, an initial inspection shows that some of the covariates are loosely correlated with primary vote. Also expected, many of the covariates exhibit medium to high correlation levels amongst themselves, e.g. negative correlation between high and low level income groups, and certain age brackets with houselhold type and tenure.

As examples, figure \@ref(fig:coalvsboomers) show a somewhat weak correlation between Coalition primary vote and percentage of baby boomer population. Figure \@ref(fig:corrlanguagereligion) presents the correlation values for religion and language attributes that aside from expected pairings (e.g. Hinduism and South Asian languages or Italian speakers and percentage of declared catholics), there is a almost exclusive positive correlation between membership to Anglican, Presbyterian and Uniting churches and percentage of monolingual English speakers. The percentage of monolingual English speakers is also negative correlated to all other language groups.


```{r coalvsboomers,fig.cap="Correlation between Coalition vote and Baby boomer population"}
dataset |>
  select(DivisionNm,election_year,COAL,Age_Baby_Boomers) |>
  ggplot(aes(x=Age_Baby_Boomers,y=COAL)) +
  geom_point(colour=auspol::party_colours()["COAL"]) +
  facet_wrap(.~ election_year, ncol=2) +
  labs(title="Coalition Primary vote by baby boomer population",
       subtitle="as percentage of electorate's population",
       x= "Baby Boomers (%)",y="Primary vote (%)")
```

```{r corrlanguagereligion, echo=FALSE,  out.width="110%", fig.cap="Correlation for selected covariates"}

cor_selection <-dataset |>
  select(matches("Religion"),
         matches("Language")) |>
  filter(!is.na(Religion_Catholic))

cor_columns <- colnames(cor_selection)
names(cor_columns) <- str_replace_all(cor_columns,"_"," ")
names(cor_columns) <- str_replace_all(names(cor_columns),"Language","Language:")
names(cor_columns) <- str_replace_all(names(cor_columns),"Religion","Religion:")

cor_columns <- sort(cor_columns)

cor_selection <- cor_selection |>
                 select(any_of(cor_columns)) |>
                 rename(any_of(cor_columns)) 


col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))

cor(cor_selection) |>
     ggcorrplot::ggcorrplot( hc.order = FALSE, 
                             type = "lower",
                             tl.cex=8,
                             lab = TRUE,
                             lab_size=1.5) +
  labs(title="Correlation between Language and Religion") +
  guides(fill=guide_legend(title="Correlation"))
  
```

Besides from this, it is worth noticing that :

-   There is no apparent change in the relationship between a given covariate and the responses when broken down by state or capital city.

-   There are also no obviously distinguishable differences when splitting results by each election.

### Dimensionality reduction using Multiple Factor Analysis {#data-mfa}

Given the large number of variables and considering their correlation, it is worth exploring if a change of space could help to better identify variation, and whether the number of covariates can be reduced in a meaningful way. For this **multiple factor analysis** (MFA) [@escofier:hal-00382085] was used, given that:

-   MFA allows to use variables that belong to groups.

-   Allows to combine quantitative and qualitative variables.

The resulting scree plot and cumulative variance is presented in figure \@ref(fig:mfascree).

```{r include=FALSE}
library(factoextra)
library(patchwork)

mfa <- readRDS(fs::path(project_path,"6. Modelling",
                         "clustering_models","MFA.rds"))
```

```{r mfascree, fig.cap="Scree plot and cumulative variance"}
screeplot <- fviz_screeplot(mfa)  +
             labs(y="Percentage of Variance")

variance_data <- mfa$eig |> 
  as_tibble() |>
  mutate(across(where(is.numeric), ~ round(.x,3))) |>
  mutate(Dimension=as.character(row_number()), .before=1) |>
  select(Dimension,`percentage of variance`)  |>
   slice_head(n=10)

variance_plot <- variance_data |> 
  waterfalls::waterfall(calc_total = FALSE,
                        rect_text_labels  = round(variance_data$`percentage of variance`,2),
                         put_rect_text_outside_when_value_below=40) +
  theme(axis.title.y = element_text(),
        axis.title.x = element_text()) +
  labs(title="Cumulative Variance",
       y="Percentage of Variance",
       x="Dimensions") +
  ylim(0,100)
  

screeplot / variance_plot 

```

In terms of interpretability of the new dimensions, figure \@ref(fig:groupbiplot) present group biplots for the 8 most important dimensions. From there, it is possible show that there is not straightforward representation expect with Dimension 2 and Education variables. 

```{r groupbiplot,fig.cap="Group plots for first 8 dimensions"}
mfa_plot <- list()
for(i in 1:4){
  mfa_plot[[length(mfa_plot)+1]] <-   fviz_mfa_var(mfa,choice="group",axes=c(2*i-1,2*i)) + 
                                      xlim(0,1) + ylim(0,1) +
                                      theme(plot.title = element_blank())
}

wrap_plots(mfa_plot) + plot_annotation(title="Variable groups - MFA")


```



<!--chapter:end:04-data.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---
# Method {#method}

```{r seven-setup,message=FALSE,warning=FALSE,echo=FALSE}
library(dplyr)
library(readr)
library(stringr)
library(here)
library(auspol)
library(flextable)
library(ggplot2)

source(here::here("formatting_defaults.R"))

project_path <- fs::path(here(),"..")


```

Hello workd

<!--chapter:end:05-method.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}
'`

<!--chapter:end:100-references.Rmd-->

# (APPENDIX) {auscensus} Vignette
*Extracted from https://carlosyanez.github.io/auscensus/articles/complex_case.html on Sunday 22 January 2023*

```{r}
library(auscensus)
library(tidyverse)
```


This vignette shows a more complex use case of auscensus. Let's assume we want to extract the percentage of Australian Citizens for all Commonwealth Electoral Divisions, as measured in last 4 Censuses (2006-2021).

An initial exploration shows that this data can be found in table 01 (across all four censuses) - which provided an statistical summary. However, is not published aggregated by electorate across all censuses.


```{r}

#| eval: true

census_tables <- list_census_tables() 

census_tables <- census_tables |>
                 filter(if_any(any_of(c("Number")),~ .x %in% c("01"))) 

tables_summary <- census_tables |>
                  select(-contains("Table")) |>
                  pivot_longer(-Number, names_to="Year",values_to = "Value") |>
                  filter(!is.na(Value)) |>
                  select(-Value)


list_census_geo_tables(year = tables_summary$Year,geo="CED|CED_2007|CED_2004",table_number = tables_summary$Number) |>
  mutate(Year=as.character(Year)) |>
  right_join(tables_summary, by=c("table_number"="Number","Year"="Year"))

```


Therefore, we will retrieve the data from the lowest statistical unit. However, SA1 were not available in 2006 - where the smallest area was a "CD".

```{r}

#| eval: true

list_census_geo_tables(year = tables_summary$Year,geo=c("SA1|CD"),table_number = tables_summary$Number) |>
   mutate(Year=as.character(Year)) |>
  right_join(tables_summary, by=c("table_number"="Number","Year"="Year")) 


```

The next step is to figure the attributes for the numbers of Australian citizen and total population, which are presented below:


```{r}

citizenship_attributes <- tibble()

for(i in 1:nrow(tables_summary)){

  table_i <- tables_summary[i,]$Number
  year_i  <- tables_summary[i,]$Year

  attr_i <- list_census_attributes(table_i) |> 
             pivot_longer(-c(Table,Attribute),
                           names_to="Year",values_to = "Value") |>
              filter(Year==year_i) |>
              filter(!is.na(Value)) |>
              select(-Value)

  citizenship_attributes <- bind_rows(attr_i,citizenship_attributes)

}



citizenship_attributes |>
  head()

```

```{r}

citizenship_attributes <- citizenship_attributes   |> 
                       distinct(Attribute,Year) |>
                      filter(str_detect(Attribute,"[Aa]ustralian")) |>
                      filter(str_detect(Attribute,"[Pp]erson")) |>
                      mutate(dummy=TRUE) |>
                      pivot_wider(names_from = Year, values_from = dummy)  |>
                      bind_rows(
                         citizenship_attributes   |> 
                       distinct(Attribute,Year) |>
                      filter(str_detect(Attribute,"^[Tt]otal")) |>
                      filter(str_detect(Attribute,"[Pp]ersons$")) |>
                      mutate(dummy=TRUE) |>
                      pivot_wider(names_from = Year, values_from = dummy)
                      )


citizenship_attributes 
```

Using *attribute_tibble_to_list*, this data frame can be converted into the required format.

```{r}

citizenship_attributes <- citizenship_attributes |>
                          select(Attribute)      |>
                          mutate(AttrNew = case_when(
                            str_detect(Attribute,"Australian") ~ "Australian Citizens",
                            str_detect(Attribute,"Total")      ~ "Total"
                          ))

levels <- attribute_tibble_to_list(citizenship_attributes)
```


Now,  we can cycle through the four censuses and extract the data. Please note that CDs and SA1s are not equivalent, but they are stored together for convenience:


```{r}
census_years <- c("2006","2011","2016","2021")

citizenship <- tibble()

for(year in census_years){

  if(year=="2006"){
    geo_structure_x <- "CD"
  } else{
    geo_structure_x <- "SA1"
  }

  citizenship_i <- get_census_summary(census_table = census_tables,
                                   selected_years = year,
                                   geo_structure=geo_structure_x,
                                   attribute = levels) 


  citizenship <- bind_rows(citizenship,citizenship_i)


}

rm(citizenship_i,geo_structure_x,levels,citizenship_attributes)



```


To aggregate the data,  **[aussiemaps::geo_aggregate()](https://gh.carlosyanez.id.au/aussiemaps/)** can help using area to apportion on non-overalpping cases. Then, this package's *calculate_percentage()* will take the totals from the list and calculate percentages.


```{r}

citizenship_ced<- tibble()
codes <- c("CD_CODE_2006","SA1_7DIGITCODE_2011","SA1_7DIGITCODE_2016","SA1_CODE_2021")
ceds  <- c("CED_NAME_2006","CED_NAME_2011","CED_NAME_2016","CED_NAME_2021")

 for(i in 1:length(census_years)){

   year <- as.double(census_years[i])

   value_i <- citizenship |> 
                  filter(Year==year)     |>
                  select(-Unit)                    |>
                  rename(!!codes[i]:="Census_Code") |>
                  collect() |>
                  aussiemaps::geo_aggregate(
                              values_col="Value",
                              original_geo=codes[i],
                              new_geo=ceds[i],
                              grouping_col = c("Year","Attribute"),
                              year=census_years[i]) |>
              rename("Unit"=ceds[i])  |>
              filter(!is.na(Unit))    |>
              filter(str_detect(Unit,"[Ss]hipping",TRUE))|>
              filter(str_detect(Unit,"[Uu]sual",TRUE))   |>
              filter(str_detect(Unit,"[Aa]pplicable",TRUE)) 


    value_i <- value_i  |> 
               auscensus::calculate_percentage(key_col = "Attribute",
                                                value_col = "Value",
                                                key_value = "Total",
                                                percentage_scale = 100)

   citizenship_ced <- bind_rows(citizenship_ced,value_i)


 }


citizenship_ced 

```

<!--chapter:end:81-auscensus.Rmd-->

# (APPENDIX) {auspol} Vignette
*Extracted from https://carlosyanez.github.io/auspol/articles/house_primary_vote.html on Sunday 22 January 2023*
```{r}
library(auspol)
library(tidyverse)
```


**auspol** includes two functions to interact with the preference distribution data:

- get_house_primary_vote()
- house_primary_vote_summary()
- house_primary_comparison_plot()
- house_primary_historic_plot()

## What is this?

If you are unfamiliar with the Australian electoral system and preferential voting, please look at this [explainer(https://www.aec.gov.au/learn/preferential-voting.html) before proceeding.

## Getting the data

*get_house_primary_vote()* is the basic function to retrieve primary vote data published by the AEC. Without any arguments, it will deliver all the results for all elections, but it comes with parameters to facilitate filtering.
For instance, to get the results for Brisbane for 2022:

```{r}
get_house_primary_vote(division="Brisbane",year=2022)
```

Both parameters can include more than one value, e.g.

```{r}
get_house_primary_vote(division="Brisbane",year=c(2019,2022))
```

```{r}
get_house_primary_vote(division=c("Brisbane","Perth"),year=c(2019,2022))
```

By default, the results are presented by polling place, with the possibility to aggregate them.

```{r}
get_house_primary_vote(division=c("Brisbane","Perth"),year=c(2019,2022),aggregation = TRUE)
```

```{r}
get_house_primary_vote(division=c("Brisbane","Perth"),year=c(2019,2022), polling_places = c("Yokine North"))
```

It is also possible to restrict the results to selected polling places



Additionally, it is possible to select one or more states instead of a group of divisions, e.g.:

```{r}
get_house_primary_vote(state=c("TAS"),year=c(2019,2022),aggregation = TRUE)
```

It is also possible to filter results by one or more parties:

```{r}
get_house_primary_vote(state=c("NT"),year=c(2019,2022),aggregation = TRUE, party_abb=c("ALP","CLP"))

```

*house_primary_vote_summary()* builds on the basic function and summarises data
.
```{r}
house_primary_vote_summary(division = "Brisbane", year=2022)
```

Using the previous filters,  it is possible to get ad-hoc summaries, for instance - all the ALP votes in Queensland in 2022, or the historic Liberal vote in Franklin.

```{r}

house_primary_vote_summary(state = "QLD", year=2022,parties="ALP")

```



```{r}
house_primary_vote_summary(division="Franklin",parties="LP")
```

## Plotting 

### Historic Trends

The first plotting convenience function in this package allows comparing the evolution of primary voting across time. This function relies on house_primary_summary and uses many of its options. Its first use is to represent party trends in one electorate:

```{r primvote1}
house_primary_historic_plot("Canberra")
```

As they can be many minor parties, it is sometimes useful just to focus on a number of parties. This function allows filtering by a number of parties or by filtering by the most voted in a certain year. In both cases, it is possible to consolidate others' votes.



```{r primvote2}
house_primary_historic_plot("Canberra", parties =3, 
                            parties_year = 2022, 
                            include_others = TRUE )

```

Finally, it is possible to aggregate party acronyms - sometimes the same party has changed named or registered differently

```{r primvote3}

house_primary_historic_plot(division="Brisbane",parties=5,
                            merge_parties = list(LNP=c("LNP","LNQ","LP"),
                                                 ON=c("HAN","ON"))) 

```

## Results for one election

This package also contains a convenience function to look at the primary vote results for one division. Lile the previous function, this also inherits many of the attributes of *get_house_primary_vote*.

```{r primvote4}
house_primary_comparison_plot(division = "Kooyong", year=2022,individualise_IND = TRUE)

```

The plots can also be displayed using bars, as shown below

```{r primvote5}
house_primary_comparison_plot(state="TAS",year=2022,parties=c("LP"),plot_format = "bar")
```

<!--chapter:end:82-auspol.Rmd-->

# (APPENDIX) {aussiemaps} Vignette
*Extracted from https://carlosyanez.github.io/aussiemaps/articles/aussiemaps.html on Sunday 22 January 2023*
```{r}
library(aussiemaps)
library(tidyverse)
```


## {aussiemaps} - Yet another maps package

This package has been built to facilitate the use of the geographic boundary files published by the Australian Bureau of Statistics (ABS). The ABS has published several boundary files - i.e. the [Australian Statistical Geography Standard (ASGS)](https://www.abs.gov.au/statistics/statistical-geography/australian-statistical-geography-standard-asgs) from 2006 onwards and the  [Australian Standard Geographical Classification (ASGC)](https://www.abs.gov.au/AUSSTATS/abs@.nsf/Latestproducts/DEDA554E1B6BB78BCA25791F000EEA26) before that - covering both:

-   Statistical Geographic Structures created and maintained by the ABS - and used to collect data.
-   Non-ABS structure, e.g Postal Areas, Electoral Divisions, LGA boundaries.

This package has four versions of the above, aligned with Census years 2006, 2011,2016 and 2021. This makes it easy to mix use with Census data packs or the {auscensus} package.

This package provides access to a processed version of those boundaries - as sf objects, allowing it to cater for the following scenarios:

* Get the boundaries of an electoral division across time.
* Get all the S1 or S1 areas within a Council area.
* Get all postcodes in a state or territory.

This repository also contains the R script used to process the files. Although not tested, the functions could also accommodate BYO structures for other years.

## Getting started.

The core function of this package is get_map(), which retrieves the sf files. get_map provides several filters to narrow down the data retrieved and avoid getting everything unless is needed. The key parameters for this function are:

- How the data will be filtered (e.g. return only objects in a particular state, council or metro area)
- Which year/version of the data will be retrieved?
- Which aggregation will be used (e.g. which will be the resulting objects)



Filters and column names follow the same name convention used in the original ABS files. The function list_attributes(), will present them in tibble format:

```{r}
list_attributes() |>
  head(10)
```

Let's say we want to retrieve all SA1 in the City of Melbourne for 2016 - this can be done via:

```{r}
melbourne_sa1 <- get_map(filters=list(LGA_NAME_2016=c("Melbourne")),
                         year=2016,
                         aggregation = c("SA1_MAINCODE_2016"))

#just an empty plot

melbourne_sa1 |>
  ggplot()+
  geom_sf(fill="azure1") +
  theme_void() +
  labs(title="SA1s in the City of Melbourne")

```

## Filtering via regular expressions

The filter arguments are intended to be regular expressions, for instance:

```{r}

preston <- get_map(filters=list(SSC_NAME_2016=c("Preston")),
                         year=2016,
                         aggregation = c("SSC_NAME_2016"))

preston |>
  select(SSC_NAME_2016,UCL_NAME_2016,STE_NAME_2016)

```

Whereas

```{r}
prestons <- get_map(filters=list(SSC_NAME_2016=c("^Pres"),
                                 STE_NAME_2016=c("Wales","^T")
                                 ),
                         year=2016,
                         aggregation = c("SSC_NAME_2016"))

prestons |>
  select(SSC_NAME_2016,UCL_NAME_2016,STE_NAME_2016)

```

## Even more complex filtering

If more complex subsetting is needed, it is possible to pass a table with the elements to be selected. In order to do that, list_structure() comes to help. This function uses the same year and filters parameters than get_map() (actually this function calls the former if no table is provided). Once you have the dataset, you can use any ad-hoc filter to get the needed structures. For example

```{r}

greater_sydney <- list_structure(year=2021,filters=list(GCCSA_NAME_2021="Greater Sydney"))

#use_cache option stores the results/reuses pre-processed results
sydney_area <- get_map(filter_table = greater_sydney,
                       year=2021,
                       aggregation = "GCCSA_NAME_2021",
                       use_cache = TRUE) 

#outline

# all suburbs starting wit A
suburbs_a_filter <- greater_sydney |>
                    filter(str_detect(SAL_NAME_2021,"^A"))

suburbs_a  <- get_map(filter_table = suburbs_a_filter,
                       year=2021,
                       aggregation = "SAL_NAME_2021") |>
                mutate(border="orange",fill="orange")


ggplot() +
  geom_sf(data=sydney_area,fill="white",colour="black")+
  geom_sf(data=suburbs_a,fill="orange") +
  labs(title="Suburbs starting with A - Sydney") +
  theme_void()

```

## Aggregation

It is worth noticing that the *aggregation* parameter accepts more than one variable. Those parameters are passed to dplyr::group_by() before aggregation - thus more variables will impact how sf objects are aggregated. For instance, if we look at the postal areas (ABS approximation of a postcode) in the cities of Melbourne and Port Phillip:

```{r}

poas_inner_melbourne <- get_map(filters=list(LGA_NAME_2021=c("Melbourne","Phillip$")),
                                year=2021,
                                aggregation = c("POA_NAME_2021","LGA_NAME_2021"))

poas_inner_melbourne |>
  mutate(colour=case_when(
    POA_NAME_2021=="3004" ~ "orange",
    TRUE ~ "grey"
  )) |>
  ggplot()+
  geom_sf(aes(fill=colour,colour=LGA_NAME_2021)) +
  scale_fill_identity() +
  theme_void() +
  labs(title="Postcode 3004 extends across two LGAs")

```
## Using external data

 This package provides sf data, thus the result can be easily merged with any other data frame. Since data has been taken from the ABS and the output contains both names and **codes** of geographic structures, data can be joined using an un-ambiguous key. Furthermore, with {auscensus}, this package can be used as data filters to retrieve said data in the first place. For example:
 
```{r}

# Chileans by Commonwealth Electoral Divisions in Metropolitan Brisbane, 2021

attr <- list_structure(year=2021,filters=list(GCCSA_NAME_2021=c("Brisbane"))) |>
        distinct(CED_NAME_2021)

chileans <- auscensus::get_census_summary(table_number= "09",
                                          selected_years = "2021",
                                          geo_structure = "CED",
                                          geo_unit_names =   attr$CED_NAME_2021,
                                          attribute = list(Chileans=c("Persons_chile_total")),
                                          reference_total = list(Total=c("Persons_total_total")),
                                          percentage_scale =100)

brisbane_ced <- get_map(filters = list(GCCSA_NAME_2021=c("Brisbane")),
                        year = 2021,
                        aggregation = c("CED_NAME_2021"),
                        use_cache = TRUE)

chileans$Value

brisbane_ced |>
  left_join(chileans,by=c("CED_NAME_2021"="Unit")) |>
  ggplot(aes(fill=Value,colour=Value)) +
  geom_sf() +
  scale_fill_continuous()+
  labs(title="Chileans in Bribane's Federal Electorates") +
  theme_void()
  

```
 
## Data Aggregation

As a bonus function, *geo_aggregate()*  aggregates data, transforming between geographic structures. For instance, let's imagine that for the previous case, it is only possible to get data by SA2. *geo_aggregate()* can aggregate the data to obtain an approximation for each electorate. When an SA1 is not fully contained by an electorate, the function will use the overlapping area as the weighting factor.

```{r}

attr <- list_structure(year=2021,filters=list(GCCSA_NAME_2021=c("Brisbane"))) |>
        distinct(SA2_CODE_2021)

chileans_sa2 <- auscensus::get_census_summary(table_number= "09",
                                          selected_years = "2021",
                                          geo_structure = "SA2",
                                          geo_unit_codes =     attr$SA2_CODE_2021,
                                          attribute = list(Chileans=c("Persons_chile_total"))) |>
                  rename("SA2_CODE_2021"="Census_Code")

# please note these Electoral divisions are not built from SA2s - proportional allocation will result in factional 
# Therefore - This is an approximation
chileans <- geo_aggregate(original_data = chileans_sa2,
                          values_col = "Value",
                          original_geo = "SA2_CODE_2021",
                          new_geo      = "CED_NAME_2021",
                          grouping_col =   c("Year","Attribute"),
                          year=2021) |>
            rename("Unit"="CED_NAME_2021")



brisbane_ced |>
  left_join(chileans,by=c("CED_NAME_2021"="Unit")) |>
  ggplot(aes(fill=Value,colour=Value)) +
  geom_sf() +
  scale_fill_continuous()+
  labs(title="Chileans in Bribane's Federal Electorates") +
  theme_void()

```

<!--chapter:end:83-aussiemaps.Rmd-->

