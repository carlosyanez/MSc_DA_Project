[["index.html", "A Minimal Book Example Chapter 1 Acknowledgements", " A Minimal Book Example John Doe 2023-02-04 Chapter 1 Acknowledgements bookdown::serve_book() bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::pdf_book&quot;) "],["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction "],["strucure.html", "Chapter 3 Strucure", " Chapter 3 Strucure _ Problem statement - Obtaining the data - EDA - Modelling - Conclusions APPENDICES - HOW we waht the data obtained - Detailed EDa - TEchnical note on buulding packages - vignettes "],["cross.html", "Chapter 4 Cross-references 4.1 Chapters and sub-chapters 4.2 Captioned figures and tables", " Chapter 4 Cross-references Cross-references make it easier for your readers to find and link to elements in your book. 4.1 Chapters and sub-chapters There are two steps to cross-reference any heading: Label the heading: # Hello world {#nice-label}. Leave the label off if you like the automated heading generated based on your heading title: for example, # Hello world = # Hello world {#hello-world}. To label an un-numbered heading, use: # Hello world {-#nice-label} or {# Hello world .unnumbered}. Next, reference the labeled heading anywhere in the text using \\@ref(nice-label); for example, please see Chapter 4. If you prefer text as the link instead of a numbered reference use: any text you want can go here. 4.2 Captioned figures and tables Figures and tables with captions can also be cross-referenced from elsewhere in your book using \\@ref(fig:chunk-label) and \\@ref(tab:chunk-label), respectively. See Figure 4.1. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 4.1: Here is a nice figure! Don’t miss Table 4.1. knitr::kable( head(pressure, 10), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 4.1: Here is a nice table! temperature pressure 0 0.0002 20 0.0012 40 0.0060 60 0.0300 80 0.0900 100 0.2700 120 0.7500 140 1.8500 160 4.2000 180 8.8000 "],["parts.html", "Chapter 5 Parts", " Chapter 5 Parts You can add parts to organize one or more book chapters together. Parts can be inserted at the top of an .Rmd file, before the first-level chapter heading in that same file. Add a numbered part: # (PART) Act one {-} (followed by # A chapter) Add an unnumbered part: # (PART\\*) Act one {-} (followed by # A chapter) Add an appendix as a special kind of un-numbered part: # (APPENDIX) Other stuff {-} (followed by # A chapter). Chapters in an appendix are prepended with letters instead of numbers. "],["footnotes-and-citations.html", "Chapter 6 Footnotes and citations 6.1 Footnotes 6.2 Citations", " Chapter 6 Footnotes and citations 6.1 Footnotes Footnotes are put inside the square brackets after a caret ^[]. Like this one 1. 6.2 Citations Reference items in your bibliography file(s) using @key. For example, we are using the bookdown package (R-bookdown?) (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and knitr (xie2015?) (this citation was added manually in an external file book.bib). Note that the .bib files need to be listed in the index.Rmd with the YAML bibliography key. The RStudio Visual Markdown Editor can also make it easier to insert citations: https://rstudio.github.io/visual-markdown-editing/#/citations This is a footnote.↩︎ "],["blocks.html", "Chapter 7 Blocks 7.1 Equations 7.2 Theorems and proofs 7.3 Callout blocks", " Chapter 7 Blocks 7.1 Equations Here is an equation. \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{7.1} \\end{equation}\\] You may refer to using \\@ref(eq:binom), like see Equation (7.1). 7.2 Theorems and proofs Labeled theorems can be referenced in text using \\@ref(thm:tri), for example, check out this smart theorem 7.1. Theorem 7.1 For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] Read more here https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html. 7.3 Callout blocks The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html "],["sharing-your-book.html", "Chapter 8 Sharing your book 8.1 Publishing 8.2 404 pages 8.3 Metadata for sharing", " Chapter 8 Sharing your book 8.1 Publishing HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html 8.2 404 pages By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you’d like to customize your 404 page instead of using the default, you may add either a _404.Rmd or _404.md file to your project root and use code and/or Markdown syntax. 8.3 Metadata for sharing Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the index.Rmd YAML. To setup, set the url for your book and the path to your cover-image file. Your book’s title and description are also used. This gitbook uses the same social sharing data across all chapters in your book- all links shared will look the same. Specify your book’s source repository on GitHub using the edit key under the configuration options in the _output.yml file, which allows users to suggest an edit by linking to a chapter’s source file. Read more about the features of this output format here: https://pkgs.rstudio.com/bookdown/reference/gitbook.html Or use: ?bookdown::gitbook "],["references.html", "References", " References "],["references-1.html", "References", " References "],["appendix-extracting-data.html", "Chapter 9 (APPENDIX) Extracting Data 9.1 Package Architecture", " Chapter 9 (APPENDIX) Extracting Data A particular challenge for this project was to efficiently and systematically being able to extract data. In this particular case, data sources are public and freely made available by Australian government departments. However, there were two challenging aspects, namely: The volume of data, especially when it comes to Census Data. This also presented a challenge in terms of selection and aggregation of data not presented at electorate level. Changes in file structure and naming convention across time, having to standardise variable names across different census and election years. The search for existing data packages did not produce satisfactory results - only a package to retrieve historical weather data was found ({cropgrowdays}(Baker and Mortlock 2021)). Therefore, as par of this project it was necessary to create the following R packages: {auspol}, a data package with containing voting tallies for the Australian House of Representatives. This package contains processed data, sourced from the Australian Electoral Commission, as well as functions to access and plot them. In addition to primary votes (the scope for this project), this also contains preferential distribution tallies. {auscensus}, a package to interact with Census Data Packs (as published by the Australian Bureau of Statistics, ABS). This package does not contain the actual data - each data pack ranges from 600 to 800 MB. {aussiemaps}, which is a rewriting of a geospatial package experiment by the author. This package contains geographical boundaries for ABS statistical structures as well as non-ABS geographies such as electoral divisions. In this project, this package is use to aggregate data from granular statistical structures to electorates. 9.1 Package Architecture The three packages have been designed using the same approach, which can be summarised by the following: References "],["appendix-auscensus-vignette.html", "Chapter 10 (APPENDIX) {auscensus} Vignette", " Chapter 10 (APPENDIX) {auscensus} Vignette Extracted from https://gh.carlosyanez.id.au/auscensus/articles/complex_case.html on Sunday 22 January 2023 This vignette shows a more complex use case of auscensus. Let’s assume we want to extract the percentage of Australian Citizens for all Commonwealth Electoral Divisions, as measured in last 4 Censuses (2006-2021). An initial exploration shows that this data can be found in table 01 (across all four censuses) - which provided an statistical summary. However, is not published aggregated by electorate across all censuses. #| eval: true census_tables &lt;- list_census_tables() |&gt; filter(Number %in% c(&quot;01&quot;)) tables_summary &lt;- census_tables |&gt; select(-contains(&quot;Table&quot;)) |&gt; pivot_longer(-Number, names_to=&quot;Year&quot;,values_to = &quot;Value&quot;) |&gt; filter(!is.na(Value)) |&gt; select(-Value) list_census_geo_tables(year = tables_summary$Year,geo=&quot;CED|CED_2007|CED_2004&quot;,table_number = tables_summary$Number) |&gt; mutate(Year=as.character(Year)) |&gt; right_join(tables_summary, by=c(&quot;table_number&quot;=&quot;Number&quot;,&quot;Year&quot;=&quot;Year&quot;)) Therefore, we will retrieve the data from the lowest statistical unit. However, SA1 were not available in 2006 - where the smallest area was a “CD”. #| eval: true list_census_geo_tables(year = tables_summary$Year,geo=c(&quot;SA1|CD&quot;),table_number = tables_summary$Number) |&gt; mutate(Year=as.character(Year)) |&gt; right_join(tables_summary, by=c(&quot;table_number&quot;=&quot;Number&quot;,&quot;Year&quot;=&quot;Year&quot;)) The next step is to figure the attributes for the numbers of Australian citizen and total population, which are presented below: citizenship_attributes &lt;- tibble() for(i in 1:nrow(tables_summary)){ table_i &lt;- tables_summary[i,]$Number year_i &lt;- tables_summary[i,]$Year attr_i &lt;- list_census_attributes(table_i) |&gt; pivot_longer(-c(Table,Attribute), names_to=&quot;Year&quot;,values_to = &quot;Value&quot;) |&gt; filter(Year==year_i) |&gt; filter(!is.na(Value)) |&gt; select(-Value) citizenship_attributes &lt;- bind_rows(attr_i,citizenship_attributes) } citizenship_attributes |&gt; head() citizenship_attributes &lt;- citizenship_attributes |&gt; distinct(Attribute,Year) |&gt; filter(str_detect(Attribute,&quot;[Aa]ustralian&quot;)) |&gt; filter(str_detect(Attribute,&quot;[Pp]erson&quot;)) |&gt; mutate(dummy=TRUE) |&gt; pivot_wider(names_from = Year, values_from = dummy) |&gt; bind_rows( citizenship_attributes |&gt; distinct(Attribute,Year) |&gt; filter(str_detect(Attribute,&quot;^[Tt]otal&quot;)) |&gt; filter(str_detect(Attribute,&quot;[Pp]ersons$&quot;)) |&gt; mutate(dummy=TRUE) |&gt; pivot_wider(names_from = Year, values_from = dummy) ) citizenship_attributes Using attribute_tibble_to_list, this data frame can be converted into the required format. citizenship_attributes &lt;- citizenship_attributes |&gt; select(Attribute) |&gt; mutate(AttrNew = case_when( str_detect(Attribute,&quot;Australian&quot;) ~ &quot;Australian Citizens&quot;, str_detect(Attribute,&quot;Total&quot;) ~ &quot;Total&quot; )) levels &lt;- attribute_tibble_to_list(citizenship_attributes) Now, we can cycle through the four censuses and extract the data. Please note that CDs and SA1s are not equivalent, but they are stored together for convenience: census_years &lt;- c(&quot;2006&quot;,&quot;2011&quot;,&quot;2016&quot;,&quot;2021&quot;) citizenship &lt;- tibble() for(year in census_years){ if(year==&quot;2006&quot;){ geo_structure_x &lt;- &quot;CD&quot; } else{ geo_structure_x &lt;- &quot;SA1&quot; } citizenship_i &lt;- get_census_summary(census_table = census_tables, selected_years = year, geo_structure=geo_structure_x, attribute = levels) citizenship &lt;- bind_rows(citizenship,citizenship_i) } ## 2006: Extracting 0 attributes. ## ERROR : [EBUSY] Failed to remove &#39;C:/Users/carlo/OneDrive/Documents/.auscensus_cache/CD_NSW_B01.csv&#39;: resource busy or locked ## ERROR : [EBUSY] Failed to remove &#39;C:/Users/carlo/OneDrive/Documents/.auscensus_cache/CD_NSW_B01.csv&#39;: resource busy or locked ## 2011: Extracting 0 attributes. ## ERROR : [EBUSY] Failed to remove &#39;C:/Users/carlo/OneDrive/Documents/.auscensus_cache/2011Census_B01_AUST_SA1_short.csv&#39;: resource busy or locked ## 2016: Extracting 0 attributes. ## ERROR : [EBUSY] Failed to remove &#39;C:/Users/carlo/OneDrive/Documents/.auscensus_cache/2016Census_G01_AUS_SA1.csv&#39;: resource busy or locked ## 2021: Extracting 0 attributes. ## ERROR : [EBUSY] Failed to remove &#39;C:/Users/carlo/OneDrive/Documents/.auscensus_cache/2021Census_G01_AUST_SA1.csv&#39;: resource busy or locked rm(citizenship_i,geo_structure_x,levels,citizenship_attributes) To aggregate the data, aussiemaps::geo_aggregate() can help using area to apportion on non-overalpping cases. Then, this package’s calculate_percentage() will take the totals from the list and calculate percentages. citizenship_ced&lt;- tibble() codes &lt;- c(&quot;CD_CODE_2006&quot;,&quot;SA1_7DIGITCODE_2011&quot;,&quot;SA1_7DIGITCODE_2016&quot;,&quot;SA1_CODE_2021&quot;) ceds &lt;- c(&quot;CED_NAME_2006&quot;,&quot;CED_NAME_2011&quot;,&quot;CED_NAME_2016&quot;,&quot;CED_NAME_2021&quot;) for(i in 1:length(census_years)){ year &lt;- as.double(census_years[i]) value_i &lt;- citizenship |&gt; filter(Year==year) |&gt; select(-Unit) |&gt; rename(!!codes[i]:=&quot;Census_Code&quot;) |&gt; collect() |&gt; aussiemaps::geo_aggregate( values_col=&quot;Value&quot;, original_geo=codes[i], new_geo=ceds[i], grouping_col = c(&quot;Year&quot;,&quot;Attribute&quot;), year=census_years[i]) |&gt; rename(&quot;Unit&quot;=ceds[i]) |&gt; filter(!is.na(Unit)) |&gt; filter(str_detect(Unit,&quot;[Ss]hipping&quot;,TRUE))|&gt; filter(str_detect(Unit,&quot;[Uu]sual&quot;,TRUE)) |&gt; filter(str_detect(Unit,&quot;[Aa]pplicable&quot;,TRUE)) value_i &lt;- value_i |&gt; auscensus::calculate_percentage(key_col = &quot;Attribute&quot;, value_col = &quot;Value&quot;, key_value = &quot;Total&quot;, percentage_scale = 100) citizenship_ced &lt;- bind_rows(citizenship_ced,value_i) } citizenship_ced "],["appendix-auspol-vignette.html", "Chapter 11 (APPENDIX) {auspol} Vignette 11.1 What is this? 11.2 Getting the data 11.3 Plotting 11.4 Results for one election", " Chapter 11 (APPENDIX) {auspol} Vignette Extracted from https://gh.carlosyanez.id.au/auspol/articles/house_primary_vote.html on Sunday 22 January 2023 auspol includes two functions to interact with the preference distribution data: get_house_primary_vote() house_primary_vote_summary() house_primary_comparison_plot() house_primary_historic_plot() 11.1 What is this? If you are unfamiliar with the Australian electoral system and preferential voting, please look at this [explainer(https://www.aec.gov.au/learn/preferential-voting.html) before proceeding. 11.2 Getting the data get_house_primary_vote() is the basic function to retrieve primary vote data published by the AEC. Without any arguments, it will deliver all the results for all elections, but it comes with parameters to facilitate filtering. For instance, to get the results for Brisbane for 2022: get_house_primary_vote(division=&quot;Brisbane&quot;,year=2022) Both parameters can include more than one value, e.g. get_house_primary_vote(division=&quot;Brisbane&quot;,year=c(2019,2022)) get_house_primary_vote(division=c(&quot;Brisbane&quot;,&quot;Perth&quot;),year=c(2019,2022)) By default, the results are presented by polling place, with the possibility to aggregate them. get_house_primary_vote(division=c(&quot;Brisbane&quot;,&quot;Perth&quot;),year=c(2019,2022),aggregation = TRUE) get_house_primary_vote(division=c(&quot;Brisbane&quot;,&quot;Perth&quot;),year=c(2019,2022), polling_places = c(&quot;Yokine North&quot;)) It is also possible to restrict the results to selected polling places Additionally, it is possible to select one or more states instead of a group of divisions, e.g.: get_house_primary_vote(state=c(&quot;TAS&quot;),year=c(2019,2022),aggregation = TRUE) It is also possible to filter results by one or more parties: get_house_primary_vote(state=c(&quot;NT&quot;),year=c(2019,2022),aggregation = TRUE, party_abb=c(&quot;ALP&quot;,&quot;CLP&quot;)) house_primary_vote_summary() builds on the basic function and summarises data . house_primary_vote_summary(division = &quot;Brisbane&quot;, year=2022) Using the previous filters, it is possible to get ad-hoc summaries, for instance - all the ALP votes in Queensland in 2022, or the historic Liberal vote in Franklin. house_primary_vote_summary(state = &quot;QLD&quot;, year=2022,parties=&quot;ALP&quot;) house_primary_vote_summary(division=&quot;Franklin&quot;,parties=&quot;LP&quot;) 11.3 Plotting 11.3.1 Historic Trends The first plotting convenience function in this package allows comparing the evolution of primary voting across time. This function relies on house_primary_summary and uses many of its options. Its first use is to represent party trends in one electorate: house_primary_historic_plot(&quot;Canberra&quot;) As they can be many minor parties, it is sometimes useful just to focus on a number of parties. This function allows filtering by a number of parties or by filtering by the most voted in a certain year. In both cases, it is possible to consolidate others’ votes. house_primary_historic_plot(&quot;Canberra&quot;, parties =3, parties_year = 2022, include_others = TRUE ) Finally, it is possible to aggregate party acronyms - sometimes the same party has changed named or registered differently house_primary_historic_plot(division=&quot;Brisbane&quot;,parties=5, merge_parties = list(LNP=c(&quot;LNP&quot;,&quot;LNQ&quot;,&quot;LP&quot;), ON=c(&quot;HAN&quot;,&quot;ON&quot;))) 11.4 Results for one election This package also contains a convenience function to look at the primary vote results for one division. Lile the previous function, this also inherits many of the attributes of get_house_primary_vote. house_primary_comparison_plot(division = &quot;Kooyong&quot;, year=2022,individualise_IND = TRUE) The plots can also be displayed using bars, as shown below house_primary_comparison_plot(state=&quot;TAS&quot;,year=2022,parties=c(&quot;LP&quot;),plot_format = &quot;bar&quot;) "],["appendix-aussiemaps-vignette.html", "Chapter 12 (APPENDIX) {aussiemaps} Vignette 12.1 {aussiemaps} - Yet another maps package 12.2 Getting started. 12.3 Filtering via regular expressions 12.4 Even more complex filtering 12.5 Aggregation 12.6 Data Aggregation", " Chapter 12 (APPENDIX) {aussiemaps} Vignette Extracted from https://gh.carlosyanez.id.au/aussiemaps/articles/aussiemaps.html on Sunday 22 January 2023 12.1 {aussiemaps} - Yet another maps package This package has been built to facilitate the use of the geographic boundary files published by the Australian Bureau of Statistics (ABS). The ABS has published several boundary files - i.e. the Australian Statistical Geography Standard (ASGS) from 2006 onwards and the Australian Standard Geographical Classification (ASGC) before that - covering both: Statistical Geographic Structures created and maintained by the ABS - and used to collect data. Non-ABS structure, e.g Postal Areas, Electoral Divisions, LGA boundaries. This package has four versions of the above, aligned with Census years 2006, 2011,2016 and 2021. This makes it easy to mix use with Census data packs or the {auscensus} package. This package provides access to a processed version of those boundaries - as sf objects, allowing it to cater for the following scenarios: Get the boundaries of an electoral division across time. Get all the S1 or S1 areas within a Council area. Get all postcodes in a state or territory. This repository also contains the R script used to process the files. Although not tested, the functions could also accommodate BYO structures for other years. 12.2 Getting started. The core function of this package is get_map(), which retrieves the sf files. get_map provides several filters to narrow down the data retrieved and avoid getting everything unless is needed. The key parameters for this function are: How the data will be filtered (e.g. return only objects in a particular state, council or metro area) Which year/version of the data will be retrieved? Which aggregation will be used (e.g. which will be the resulting objects) Filters and column names follow the same name convention used in the original ABS files. The function list_attributes(), will present them in tibble format: list_attributes() |&gt; head(10) ## ℹ Running gh query ℹ Running gh query, got 100 records of about 200 Let’s say we want to retrieve all SA1 in the City of Melbourne for 2016 - this can be done via: melbourne_sa1 &lt;- get_map(filters=list(LGA_NAME_2016=c(&quot;Melbourne&quot;)), year=2016, aggregation = c(&quot;SA1_MAINCODE_2016&quot;)) ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 249 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Victoria&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 249 features and 37 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 144.8971 ymin: -37.85067 xmax: 144.9914 ymax: -37.77545 ## Geodetic CRS: GDA94 ## Spherical geometry (s2) switched off #just an empty plot melbourne_sa1 |&gt; ggplot()+ geom_sf(fill=&quot;azure1&quot;) + theme_void() + labs(title=&quot;SA1s in the City of Melbourne&quot;) 12.3 Filtering via regular expressions The filter arguments are intended to be regular expressions, for instance: preston &lt;- get_map(filters=list(SSC_NAME_2016=c(&quot;Preston&quot;)), year=2016, aggregation = c(&quot;SSC_NAME_2016&quot;)) ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 119 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_New.South.Wales&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 36 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 150.8487 ymin: -33.95678 xmax: 150.8979 ymax: -33.9263 ## Geodetic CRS: GDA94 ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 119 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Queensland&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 5 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 148.6178 ymin: -27.68302 xmax: 152.0004 ymax: -20.34465 ## Geodetic CRS: GDA94 ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 119 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Tasmania&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 2 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 145.9943 ymin: -41.3658 xmax: 146.1147 ymax: -41.24951 ## Geodetic CRS: GDA94 ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 119 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Victoria&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 74 features and 37 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 144.979 ymin: -37.75573 xmax: 145.0383 ymax: -37.72792 ## Geodetic CRS: GDA94 ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 119 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Western.Australia&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 2 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 115.6286 ymin: -33.44906 xmax: 116.1876 ymax: -32.79339 ## Geodetic CRS: GDA94 preston |&gt; select(SSC_NAME_2016,UCL_NAME_2016,STE_NAME_2016) ## Simple feature collection with 8 features and 3 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 115.6286 ymin: -41.3658 xmax: 152.0004 ymax: -20.34465 ## Geodetic CRS: GDA94 Whereas prestons &lt;- get_map(filters=list(SSC_NAME_2016=c(&quot;^Pres&quot;), STE_NAME_2016=c(&quot;Wales&quot;,&quot;^T&quot;) ), year=2016, aggregation = c(&quot;SSC_NAME_2016&quot;)) ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 38 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_New.South.Wales&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 36 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 150.8487 ymin: -33.95678 xmax: 150.8979 ymax: -33.9263 ## Geodetic CRS: GDA94 ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 38 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Tasmania&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 2 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 146.0066 ymin: -41.33851 xmax: 146.1147 ymax: -41.09649 ## Geodetic CRS: GDA94 prestons |&gt; select(SSC_NAME_2016,UCL_NAME_2016,STE_NAME_2016) ## Simple feature collection with 3 features and 3 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 146.0066 ymin: -41.33851 xmax: 150.8979 ymax: -33.9263 ## Geodetic CRS: GDA94 12.4 Even more complex filtering If more complex subsetting is needed, it is possible to pass a table with the elements to be selected. In order to do that, list_structure() comes to help. This function uses the same year and filters parameters than get_map() (actually this function calls the former if no table is provided). Once you have the dataset, you can use any ad-hoc filter to get the needed structures. For example greater_sydney &lt;- list_structure(year=2021,filters=list(GCCSA_NAME_2021=&quot;Greater Sydney&quot;)) #use_cache option stores the results/reuses pre-processed results sydney_area &lt;- get_map(filter_table = greater_sydney, year=2021, aggregation = &quot;GCCSA_NAME_2021&quot;, use_cache = TRUE) ## loading from cache: C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/8c99638c.gpkg ## Reading layer `8c99638c&#39; from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\8c99638c.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 1 feature and 39 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 149.9719 ymin: -34.33116 xmax: 151.6301 ymax: -33.00031 ## Geodetic CRS: GDA2020 #outline # all suburbs starting wit A suburbs_a_filter &lt;- greater_sydney |&gt; filter(str_detect(SAL_NAME_2021,&quot;^A&quot;)) suburbs_a &lt;- get_map(filter_table = suburbs_a_filter, year=2021, aggregation = &quot;SAL_NAME_2021&quot;) |&gt; mutate(border=&quot;orange&quot;,fill=&quot;orange&quot;) ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 473 features with 42 fields without geometries. ## Reading query `SELECT * FROM &#39;2021_New.South.Wales&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 473 features and 40 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 150.6731 ymin: -34.25982 xmax: 151.4437 ymax: -33.25952 ## Geodetic CRS: GDA2020 ggplot() + geom_sf(data=sydney_area,fill=&quot;white&quot;,colour=&quot;black&quot;)+ geom_sf(data=suburbs_a,fill=&quot;orange&quot;) + labs(title=&quot;Suburbs starting with A - Sydney&quot;) + theme_void() 12.5 Aggregation It is worth noticing that the aggregation parameter accepts more than one variable. Those parameters are passed to dplyr::group_by() before aggregation - thus more variables will impact how sf objects are aggregated. For instance, if we look at the postal areas (ABS approximation of a postcode) in the cities of Melbourne and Port Phillip: poas_inner_melbourne &lt;- get_map(filters=list(LGA_NAME_2022=c(&quot;Melbourne&quot;,&quot;Phillip$&quot;)), year=2021, aggregation = c(&quot;POA_NAME_2021&quot;,&quot;LGA_NAME_2022&quot;)) ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 626 features with 42 fields without geometries. ## Reading query `SELECT * FROM &#39;2021_Victoria&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 626 features and 43 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 144.8971 ymin: -37.89172 xmax: 145.0105 ymax: -37.77543 ## Geodetic CRS: GDA2020 poas_inner_melbourne |&gt; mutate(colour=case_when( POA_NAME_2021==&quot;3004&quot; ~ &quot;orange&quot;, TRUE ~ &quot;grey&quot; )) |&gt; ggplot()+ geom_sf(aes(fill=colour,colour=LGA_NAME_2022)) + scale_fill_identity() + theme_void() + labs(title=&quot;Postcode 3004 extends across two LGAs&quot;) ## Using external data This package provides sf data, thus the result can be easily merged with any other data frame. Since data has been taken from the ABS and the output contains both names and codes of geographic structures, data can be joined using an un-ambiguous key. Furthermore, with {auscensus}, this package can be used as data filters to retrieve said data in the first place. For example: # Chileans by Commonwealth Electoral Divisions in Metropolitan Brisbane, 2021 attr &lt;- list_structure(year=2021,filters=list(GCCSA_NAME_2021=c(&quot;Brisbane&quot;))) |&gt; distinct(CED_NAME_2021) chileans &lt;- auscensus::get_census_summary(table_number= &quot;09&quot;, selected_years = &quot;2021&quot;, geo_structure = &quot;CED&quot;, geo_unit_names = attr$CED_NAME_2021, attribute = list(Chileans=c(&quot;Persons_chile_total&quot;)), reference_total = list(Total=c(&quot;Persons_total_total&quot;)), percentage_scale =100) brisbane_ced &lt;- get_map(filters = list(GCCSA_NAME_2021=c(&quot;Brisbane&quot;)), year = 2021, aggregation = c(&quot;CED_NAME_2021&quot;), use_cache = TRUE) ## loading from cache: C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/b26452fe.gpkg ## Reading layer `b26452fe&#39; from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\b26452fe.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 15 features and 39 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 152.0734 ymin: -28.36387 xmax: 153.5467 ymax: -26.45233 ## Geodetic CRS: GDA2020 chileans$Value ## [1] 85 109 64 228 44 90 241 87 66 180 267 107 96 223 66 brisbane_ced |&gt; left_join(chileans,by=c(&quot;CED_NAME_2021&quot;=&quot;Unit&quot;)) |&gt; ggplot(aes(fill=Value,colour=Value)) + geom_sf() + scale_fill_continuous()+ labs(title=&quot;Chileans in Bribane&#39;s Federal Electorates&quot;) + theme_void() 12.6 Data Aggregation As a bonus function, geo_aggregate() aggregates data, transforming between geographic structures. For instance, let’s imagine that for the previous case, it is only possible to get data by SA2. geo_aggregate() can aggregate the data to obtain an approximation for each electorate. When an SA1 is not fully contained by an electorate, the function will use the overlapping area as the weighting factor. attr &lt;- list_structure(year=2021,filters=list(GCCSA_NAME_2021=c(&quot;Brisbane&quot;))) |&gt; distinct(SA2_CODE_2021) chileans_sa2 &lt;- auscensus::get_census_summary(table_number= &quot;09&quot;, selected_years = &quot;2021&quot;, geo_structure = &quot;SA2&quot;, geo_unit_codes = attr$SA2_CODE_2021, attribute = list(Chileans=c(&quot;Persons_chile_total&quot;))) |&gt; rename(&quot;SA2_CODE_2021&quot;=&quot;Census_Code&quot;) # please note these Electoral divisions are not built from SA2s - proportional allocation will result in factional # Therefore - This is an approximation chileans &lt;- geo_aggregate(original_data = chileans_sa2, values_col = &quot;Value&quot;, original_geo = &quot;SA2_CODE_2021&quot;, new_geo = &quot;CED_NAME_2021&quot;, grouping_col = c(&quot;Year&quot;,&quot;Attribute&quot;), year=2021) |&gt; rename(&quot;Unit&quot;=&quot;CED_NAME_2021&quot;) brisbane_ced |&gt; left_join(chileans,by=c(&quot;CED_NAME_2021&quot;=&quot;Unit&quot;)) |&gt; ggplot(aes(fill=Value,colour=Value)) + geom_sf() + scale_fill_continuous()+ labs(title=&quot;Chileans in Bribane&#39;s Federal Electorates&quot;) + theme_void() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
