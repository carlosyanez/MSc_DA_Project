[["index.html", "A Minimal Book Example Chapter 1 Acknowledgements", " A Minimal Book Example John Doe 2023-01-22 Chapter 1 Acknowledgements bookdown::serve_book() bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::pdf_book&quot;) "],["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction "],["strucure.html", "Chapter 3 Strucure", " Chapter 3 Strucure _ Problem statement - Obtaining the data - EDA - Modelling - Conclusions APPENDICES - HOW we waht the data obtained - Detailed EDa - TEchnical note on buulding packages - vignettes "],["cross.html", "Chapter 4 Cross-references 4.1 Chapters and sub-chapters 4.2 Captioned figures and tables", " Chapter 4 Cross-references Cross-references make it easier for your readers to find and link to elements in your book. 4.1 Chapters and sub-chapters There are two steps to cross-reference any heading: Label the heading: # Hello world {#nice-label}. Leave the label off if you like the automated heading generated based on your heading title: for example, # Hello world = # Hello world {#hello-world}. To label an un-numbered heading, use: # Hello world {-#nice-label} or {# Hello world .unnumbered}. Next, reference the labeled heading anywhere in the text using \\@ref(nice-label); for example, please see Chapter 4. If you prefer text as the link instead of a numbered reference use: any text you want can go here. 4.2 Captioned figures and tables Figures and tables with captions can also be cross-referenced from elsewhere in your book using \\@ref(fig:chunk-label) and \\@ref(tab:chunk-label), respectively. See Figure 4.1. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 4.1: Here is a nice figure! Don’t miss Table 4.1. knitr::kable( head(pressure, 10), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 4.1: Here is a nice table! temperature pressure 0 0.0002 20 0.0012 40 0.0060 60 0.0300 80 0.0900 100 0.2700 120 0.7500 140 1.8500 160 4.2000 180 8.8000 "],["parts.html", "Chapter 5 Parts", " Chapter 5 Parts You can add parts to organize one or more book chapters together. Parts can be inserted at the top of an .Rmd file, before the first-level chapter heading in that same file. Add a numbered part: # (PART) Act one {-} (followed by # A chapter) Add an unnumbered part: # (PART\\*) Act one {-} (followed by # A chapter) Add an appendix as a special kind of un-numbered part: # (APPENDIX) Other stuff {-} (followed by # A chapter). Chapters in an appendix are prepended with letters instead of numbers. "],["footnotes-and-citations.html", "Chapter 6 Footnotes and citations 6.1 Footnotes 6.2 Citations", " Chapter 6 Footnotes and citations 6.1 Footnotes Footnotes are put inside the square brackets after a caret ^[]. Like this one 1. 6.2 Citations Reference items in your bibliography file(s) using @key. For example, we are using the bookdown package (Xie 2022) (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and knitr (Xie 2015) (this citation was added manually in an external file book.bib). Note that the .bib files need to be listed in the index.Rmd with the YAML bibliography key. The RStudio Visual Markdown Editor can also make it easier to insert citations: https://rstudio.github.io/visual-markdown-editing/#/citations References "],["blocks.html", "Chapter 7 Blocks 7.1 Equations 7.2 Theorems and proofs 7.3 Callout blocks", " Chapter 7 Blocks 7.1 Equations Here is an equation. \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{7.1} \\end{equation}\\] You may refer to using \\@ref(eq:binom), like see Equation (7.1). 7.2 Theorems and proofs Labeled theorems can be referenced in text using \\@ref(thm:tri), for example, check out this smart theorem 7.1. Theorem 7.1 For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] Read more here https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html. 7.3 Callout blocks The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html "],["sharing-your-book.html", "Chapter 8 Sharing your book 8.1 Publishing 8.2 404 pages 8.3 Metadata for sharing", " Chapter 8 Sharing your book 8.1 Publishing HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html 8.2 404 pages By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you’d like to customize your 404 page instead of using the default, you may add either a _404.Rmd or _404.md file to your project root and use code and/or Markdown syntax. 8.3 Metadata for sharing Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the index.Rmd YAML. To setup, set the url for your book and the path to your cover-image file. Your book’s title and description are also used. This gitbook uses the same social sharing data across all chapters in your book- all links shared will look the same. Specify your book’s source repository on GitHub using the edit key under the configuration options in the _output.yml file, which allows users to suggest an edit by linking to a chapter’s source file. Read more about the features of this output format here: https://pkgs.rstudio.com/bookdown/reference/gitbook.html Or use: ?bookdown::gitbook "],["references.html", "References", " References "],["references-1.html", "References", " References "],["appendix-auscensus-vignette.html", "Chapter 9 (APPENDIX) {auscensus} Vignette", " Chapter 9 (APPENDIX) {auscensus} Vignette Extracted from https://gh.carlosyanez.id.au/auscensus/articles/complex_case.html on Sunday 22 January 2023 This vignette shows a more complex use case of auscensus. Let’s assume we want to extract the percentage of Australian Citizens for all Commonwealth Electoral Divisions, as measured in last 4 Censuses (2006-2021). An initial exploration shows that this data can be found in table 01 (across all four censuses) - which provided an statistical summary. However, is not published aggregated by electorate across all censuses. #| eval: true census_tables &lt;- list_census_tables() |&gt; filter(Number %in% c(&quot;01&quot;)) tables_summary &lt;- census_tables |&gt; select(-contains(&quot;Table&quot;)) |&gt; pivot_longer(-Number, names_to=&quot;Year&quot;,values_to = &quot;Value&quot;) |&gt; filter(!is.na(Value)) |&gt; select(-Value) list_census_geo_tables(year = tables_summary$Year,geo=&quot;CED|CED_2007|CED_2004&quot;,table_number = tables_summary$Number) |&gt; mutate(Year=as.character(Year)) |&gt; right_join(tables_summary, by=c(&quot;table_number&quot;=&quot;Number&quot;,&quot;Year&quot;=&quot;Year&quot;)) ## # A tibble: 4 x 3 ## Year table_number CED ## &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 2011 01 TRUE ## 2 2016 01 TRUE ## 3 2021 01 TRUE ## 4 2006 01 NA Therefore, we will retrieve the data from the lowest statistical unit. However, SA1 were not available in 2006 - where the smallest area was a “CD”. #| eval: true list_census_geo_tables(year = tables_summary$Year,geo=c(&quot;SA1|CD&quot;),table_number = tables_summary$Number) |&gt; mutate(Year=as.character(Year)) |&gt; right_join(tables_summary, by=c(&quot;table_number&quot;=&quot;Number&quot;,&quot;Year&quot;=&quot;Year&quot;)) ## # A tibble: 4 x 4 ## Year table_number CD SA1 ## &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; ## 1 2006 01 TRUE NA ## 2 2011 01 NA TRUE ## 3 2016 01 NA TRUE ## 4 2021 01 NA TRUE The next step is to figure the attributes for the numbers of Australian citizen and total population, which are presented below: citizenship_attributes &lt;- tibble() for(i in 1:nrow(tables_summary)){ table_i &lt;- tables_summary[i,]$Number year_i &lt;- tables_summary[i,]$Year attr_i &lt;- list_census_attributes(table_i) |&gt; pivot_longer(-c(Table,Attribute), names_to=&quot;Year&quot;,values_to = &quot;Value&quot;) |&gt; filter(Year==year_i) |&gt; filter(!is.na(Value)) |&gt; select(-Value) citizenship_attributes &lt;- bind_rows(attr_i,citizenship_attributes) } citizenship_attributes |&gt; head() ## # A tibble: 6 x 3 ## Table Attribute Year ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 01 Total Persons_males 2006 ## 2 01 Total Persons_females 2006 ## 3 01 Total Persons_persons 2006 ## 4 01 Age Groups: 0-4 Years_males 2006 ## 5 01 Age Groups: 0-4 Years_females 2006 ## 6 01 Age Groups: 0-4 Years_persons 2006 citizenship_attributes &lt;- citizenship_attributes |&gt; distinct(Attribute,Year) |&gt; filter(str_detect(Attribute,&quot;[Aa]ustralian&quot;)) |&gt; filter(str_detect(Attribute,&quot;[Pp]erson&quot;)) |&gt; mutate(dummy=TRUE) |&gt; pivot_wider(names_from = Year, values_from = dummy) |&gt; bind_rows( citizenship_attributes |&gt; distinct(Attribute,Year) |&gt; filter(str_detect(Attribute,&quot;^[Tt]otal&quot;)) |&gt; filter(str_detect(Attribute,&quot;[Pp]ersons$&quot;)) |&gt; mutate(dummy=TRUE) |&gt; pivot_wider(names_from = Year, values_from = dummy) ) citizenship_attributes ## # A tibble: 4 x 5 ## Attribute `2006` `2011` `2016` `2021` ## &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; ## 1 Australian Citizen_persons TRUE NA NA NA ## 2 Australian_citizen_persons NA TRUE TRUE TRUE ## 3 Total Persons_persons TRUE NA NA NA ## 4 Total_persons_persons NA TRUE TRUE TRUE Using attribute_tibble_to_list, this data frame can be converted into the required format. citizenship_attributes &lt;- citizenship_attributes |&gt; select(Attribute) |&gt; mutate(AttrNew = case_when( str_detect(Attribute,&quot;Australian&quot;) ~ &quot;Australian Citizens&quot;, str_detect(Attribute,&quot;Total&quot;) ~ &quot;Total&quot; )) levels &lt;- attribute_tibble_to_list(citizenship_attributes) Now, we can cycle through the four censuses and extract the data. Please note that CDs and SA1s are not equivalent, but they are stored together for convenience: census_years &lt;- c(&quot;2006&quot;,&quot;2011&quot;,&quot;2016&quot;,&quot;2021&quot;) citizenship &lt;- tibble() for(year in census_years){ if(year==&quot;2006&quot;){ geo_structure_x &lt;- &quot;CD&quot; } else{ geo_structure_x &lt;- &quot;SA1&quot; } citizenship_i &lt;- get_census_summary(census_table = census_tables, selected_years = year, geo_structure=geo_structure_x, attribute = levels) citizenship &lt;- bind_rows(citizenship,citizenship_i) } ## 2006: Extracting 0 attributes. ## ERROR : [EBUSY] Failed to remove &#39;C:/Users/carlo/OneDrive/Documents/.auscensus_cache/CD_NSW_B01.csv&#39;: resource busy or locked ## 2011: Extracting 0 attributes. ## ERROR : [EBUSY] Failed to remove &#39;C:/Users/carlo/OneDrive/Documents/.auscensus_cache/2011Census_B01_AUST_SA1_short.csv&#39;: resource busy or locked ## 2016: Extracting 0 attributes. ## ERROR : [EBUSY] Failed to remove &#39;C:/Users/carlo/OneDrive/Documents/.auscensus_cache/2016Census_G01_AUS_SA1.csv&#39;: resource busy or locked ## 2021: Extracting 0 attributes. ## ERROR : [EBUSY] Failed to remove &#39;C:/Users/carlo/OneDrive/Documents/.auscensus_cache/2021Census_G01_AUST_SA1.csv&#39;: resource busy or locked rm(citizenship_i,geo_structure_x,levels,citizenship_attributes) To aggregate the data, aussiemaps::geo_aggregate() can help using area to apportion on non-overalpping cases. Then, this package’s calculate_percentage() will take the totals from the list and calculate percentages. citizenship_ced&lt;- tibble() codes &lt;- c(&quot;CD_CODE_2006&quot;,&quot;SA1_7DIGITCODE_2011&quot;,&quot;SA1_7DIGITCODE_2016&quot;,&quot;SA1_CODE_2021&quot;) ceds &lt;- c(&quot;CED_NAME_2006&quot;,&quot;CED_NAME_2011&quot;,&quot;CED_NAME_2016&quot;,&quot;CED_NAME_2021&quot;) for(i in 1:length(census_years)){ year &lt;- as.double(census_years[i]) value_i &lt;- citizenship |&gt; filter(Year==year) |&gt; select(-Unit) |&gt; rename(!!codes[i]:=&quot;Census_Code&quot;) |&gt; collect() |&gt; aussiemaps::geo_aggregate( values_col=&quot;Value&quot;, original_geo=codes[i], new_geo=ceds[i], grouping_col = c(&quot;Year&quot;,&quot;Attribute&quot;), year=census_years[i]) |&gt; rename(&quot;Unit&quot;=ceds[i]) |&gt; filter(!is.na(Unit)) |&gt; filter(str_detect(Unit,&quot;[Ss]hipping&quot;,TRUE))|&gt; filter(str_detect(Unit,&quot;[Uu]sual&quot;,TRUE)) |&gt; filter(str_detect(Unit,&quot;[Aa]pplicable&quot;,TRUE)) value_i &lt;- value_i |&gt; auscensus::calculate_percentage(key_col = &quot;Attribute&quot;, value_col = &quot;Value&quot;, key_value = &quot;Total&quot;, percentage_scale = 100) citizenship_ced &lt;- bind_rows(citizenship_ced,value_i) } citizenship_ced ## # A tibble: 595 x 6 ## Unit Year Attribute Value Total Percentage ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelaide 2006 Australian Citizens 115908 140151 82.7 ## 2 Aston 2006 Australian Citizens 115010 129463 88.8 ## 3 Ballarat 2006 Australian Citizens 118247 129221 91.5 ## 4 Banks 2006 Australian Citizens 104181 118371 88.0 ## 5 Barker 2006 Australian Citizens 133033 145410 91.5 ## 6 Barton 2006 Australian Citizens 105287 131234 80.2 ## 7 Bass 2006 Australian Citizens 85631 94270 90.8 ## 8 Batman 2006 Australian Citizens 105561 128107 82.4 ## 9 Bendigo 2006 Australian Citizens 121930 131885 92.5 ## 10 Bennelong 2006 Australian Citizens 104473 129340 80.8 ## # ... with 585 more rows "],["appendix-auspol-vignette.html", "Chapter 10 (APPENDIX) {auspol} Vignette 10.1 What is this? 10.2 Getting the data 10.3 Plotting 10.4 Results for one election", " Chapter 10 (APPENDIX) {auspol} Vignette Extracted from https://gh.carlosyanez.id.au/auspol/articles/house_primary_vote.html on Sunday 22 January 2023 auspol includes two functions to interact with the preference distribution data: get_house_primary_vote() house_primary_vote_summary() house_primary_comparison_plot() house_primary_historic_plot() 10.1 What is this? If you are unfamiliar with the Australian electoral system and preferential voting, please look at this [explainer(https://www.aec.gov.au/learn/preferential-voting.html) before proceeding. 10.2 Getting the data get_house_primary_vote() is the basic function to retrieve primary vote data published by the AEC. Without any arguments, it will deliver all the results for all elections, but it comes with parameters to facilitate filtering. For instance, to get the results for Brisbane for 2022: get_house_primary_vote(division=&quot;Brisbane&quot;,year=2022) ## # A tibble: 344 x 17 ## Year StateAb DivisionID DivisionNm PollingPlaceID Polling~1 Candi~2 Surname GivenNm Ballo~3 Elected Histo~4 PartyAb PartyNm Ordin~5 Swing Sitti~6 ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 2022 QLD 156 Brisbane 83397 Alderley 37204 KENNEDY Tiana 1 FALSE FALSE AJP Animal~ 23 2.31 FALSE ## 2 2022 QLD 156 Brisbane 83397 Alderley 35972 KNUDSON Justin~ 2 FALSE FALSE UAPP United~ 25 0.77 FALSE ## 3 2022 QLD 156 Brisbane 83397 Alderley 37338 BATES Stephen 3 TRUE FALSE GRN Queens~ 251 3.43 FALSE ## 4 2022 QLD 156 Brisbane 83397 Alderley 37230 JARRETT Madonna 4 FALSE FALSE ALP Austra~ 315 1.27 FALSE ## 5 2022 QLD 156 Brisbane 83397 Alderley 37482 EVANS Trevor 5 FALSE TRUE LNP Libera~ 328 -9.97 FALSE ## 6 2022 QLD 156 Brisbane 83397 Alderley 38213 HOLD Trevor 6 FALSE FALSE ON Paulin~ 31 1.5 FALSE ## 7 2022 QLD 156 Brisbane 83397 Alderley 37311 BULL Anthony 7 FALSE FALSE LDP Libera~ 22 2.21 FALSE ## 8 2022 QLD 156 Brisbane 83397 Alderley 999 Inform~ Inform~ 999 FALSE FALSE Inform~ Inform~ 20 -1.17 FALSE ## 9 2022 QLD 156 Brisbane 6017 Ascot 37204 KENNEDY Tiana 1 FALSE FALSE AJP Animal~ 35 1.65 FALSE ## 10 2022 QLD 156 Brisbane 6017 Ascot 35972 KNUDSON Justin~ 2 FALSE FALSE UAPP United~ 62 2.06 FALSE ## # ... with 334 more rows, and abbreviated variable names 1: PollingPlace, 2: CandidateID, 3: BallotPosition, 4: HistoricElected, 5: OrdinaryVotes, ## # 6: SittingMemberFl Both parameters can include more than one value, e.g. get_house_primary_vote(division=&quot;Brisbane&quot;,year=c(2019,2022)) ## # A tibble: 712 x 17 ## Year StateAb DivisionID DivisionNm PollingPlaceID Polling~1 Candi~2 Surname GivenNm Ballo~3 Elected Histo~4 PartyAb PartyNm Ordin~5 Swing Sitti~6 ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 2022 QLD 156 Brisbane 83397 Alderley 37204 KENNEDY Tiana 1 FALSE FALSE AJP Animal~ 23 2.31 FALSE ## 2 2022 QLD 156 Brisbane 83397 Alderley 35972 KNUDSON Justin~ 2 FALSE FALSE UAPP United~ 25 0.77 FALSE ## 3 2022 QLD 156 Brisbane 83397 Alderley 37338 BATES Stephen 3 TRUE FALSE GRN Queens~ 251 3.43 FALSE ## 4 2022 QLD 156 Brisbane 83397 Alderley 37230 JARRETT Madonna 4 FALSE FALSE ALP Austra~ 315 1.27 FALSE ## 5 2022 QLD 156 Brisbane 83397 Alderley 37482 EVANS Trevor 5 FALSE TRUE LNP Libera~ 328 -9.97 FALSE ## 6 2022 QLD 156 Brisbane 83397 Alderley 38213 HOLD Trevor 6 FALSE FALSE ON Paulin~ 31 1.5 FALSE ## 7 2022 QLD 156 Brisbane 83397 Alderley 37311 BULL Anthony 7 FALSE FALSE LDP Libera~ 22 2.21 FALSE ## 8 2022 QLD 156 Brisbane 83397 Alderley 999 Inform~ Inform~ 999 FALSE FALSE Inform~ Inform~ 20 -1.17 FALSE ## 9 2022 QLD 156 Brisbane 6017 Ascot 37204 KENNEDY Tiana 1 FALSE FALSE AJP Animal~ 35 1.65 FALSE ## 10 2022 QLD 156 Brisbane 6017 Ascot 35972 KNUDSON Justin~ 2 FALSE FALSE UAPP United~ 62 2.06 FALSE ## # ... with 702 more rows, and abbreviated variable names 1: PollingPlace, 2: CandidateID, 3: BallotPosition, 4: HistoricElected, 5: OrdinaryVotes, ## # 6: SittingMemberFl get_house_primary_vote(division=c(&quot;Brisbane&quot;,&quot;Perth&quot;),year=c(2019,2022)) ## # A tibble: 1,783 x 17 ## Year StateAb DivisionID DivisionNm PollingPlaceID Polling~1 Candi~2 Surname GivenNm Ballo~3 Elected Histo~4 PartyAb PartyNm Ordin~5 Swing Sitti~6 ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 2022 QLD 156 Brisbane 83397 Alderley 37204 KENNEDY Tiana 1 FALSE FALSE AJP Animal~ 23 2.31 FALSE ## 2 2022 QLD 156 Brisbane 83397 Alderley 35972 KNUDSON Justin~ 2 FALSE FALSE UAPP United~ 25 0.77 FALSE ## 3 2022 QLD 156 Brisbane 83397 Alderley 37338 BATES Stephen 3 TRUE FALSE GRN Queens~ 251 3.43 FALSE ## 4 2022 QLD 156 Brisbane 83397 Alderley 37230 JARRETT Madonna 4 FALSE FALSE ALP Austra~ 315 1.27 FALSE ## 5 2022 QLD 156 Brisbane 83397 Alderley 37482 EVANS Trevor 5 FALSE TRUE LNP Libera~ 328 -9.97 FALSE ## 6 2022 QLD 156 Brisbane 83397 Alderley 38213 HOLD Trevor 6 FALSE FALSE ON Paulin~ 31 1.5 FALSE ## 7 2022 QLD 156 Brisbane 83397 Alderley 37311 BULL Anthony 7 FALSE FALSE LDP Libera~ 22 2.21 FALSE ## 8 2022 QLD 156 Brisbane 83397 Alderley 999 Inform~ Inform~ 999 FALSE FALSE Inform~ Inform~ 20 -1.17 FALSE ## 9 2022 QLD 156 Brisbane 6017 Ascot 37204 KENNEDY Tiana 1 FALSE FALSE AJP Animal~ 35 1.65 FALSE ## 10 2022 QLD 156 Brisbane 6017 Ascot 35972 KNUDSON Justin~ 2 FALSE FALSE UAPP United~ 62 2.06 FALSE ## # ... with 1,773 more rows, and abbreviated variable names 1: PollingPlace, 2: CandidateID, 3: BallotPosition, 4: HistoricElected, 5: OrdinaryVotes, ## # 6: SittingMemberFl By default, the results are presented by polling place, with the possibility to aggregate them. get_house_primary_vote(division=c(&quot;Brisbane&quot;,&quot;Perth&quot;),year=c(2019,2022),aggregation = TRUE) ## # A tibble: 37 x 14 ## Year StateAb DivisionID DivisionNm CandidateID Surname GivenNm BallotPosition Elected HistoricElected PartyAb PartyNm Sitti~1 Ordin~2 ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;int&gt; ## 1 2019 QLD 156 Brisbane 999 Informal Informal 999 FALSE FALSE Informal Informal FALSE 1999 ## 2 2019 QLD 156 Brisbane 32751 PERRY Anne 1 FALSE FALSE ON Pauline Hanson~ FALSE 1641 ## 3 2019 QLD 156 Brisbane 32946 NEWBURY Paul 6 FALSE FALSE ALP Australian Lab~ FALSE 19018 ## 4 2019 QLD 156 Brisbane 32960 WHITTAKER Aaron 3 FALSE FALSE UAPP United Austral~ FALSE 975 ## 5 2019 QLD 156 Brisbane 33144 BARTLETT Andrew 4 FALSE FALSE GRN The Greens FALSE 17247 ## 6 2019 QLD 156 Brisbane 33206 EVANS Trevor 2 TRUE TRUE LNP Liberal Nation~ FALSE 36119 ## 7 2019 QLD 156 Brisbane 33224 EMANUEL Kamala 7 FALSE FALSE SAL Socialist Alli~ FALSE 528 ## 8 2019 QLD 156 Brisbane 33326 JEANNERET Rod 5 FALSE FALSE FACN FRASER ANNING&#39;~ FALSE 526 ## 9 2019 WA 245 Perth 999 Informal Informal 999 FALSE FALSE Informal Informal FALSE 3548 ## 10 2019 WA 245 Perth 32155 PERKS Caroline 6 FALSE FALSE GRN The Greens (WA) FALSE 13234 ## # ... with 27 more rows, and abbreviated variable names 1: SittingMemberFl, 2: OrdinaryVotes get_house_primary_vote(division=c(&quot;Brisbane&quot;,&quot;Perth&quot;),year=c(2019,2022), polling_places = c(&quot;Yokine North&quot;)) ## # A tibble: 12 x 17 ## Year StateAb DivisionID DivisionNm PollingPlaceID Pollin~1 Candi~2 Surname GivenNm Ballo~3 Elected Histo~4 PartyAb PartyNm Ordin~5 Swing Sitti~6 ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 2022 WA 245 Perth 8203 Yokine ~ 37417 BAILEY Cameron 1 FALSE FALSE ON Paulin~ 25 -0.97 FALSE ## 2 2022 WA 245 Perth 8203 Yokine ~ 36515 POWELL Dean 2 FALSE FALSE AUC Austra~ 18 0.2 FALSE ## 3 2022 WA 245 Perth 8203 Yokine ~ 37748 CONNOR Sean 3 FALSE FALSE GAP The Gr~ 14 1.54 FALSE ## 4 2022 WA 245 Perth 8203 Yokine ~ 37803 VOS Dave 4 FALSE FALSE WAP WESTER~ 18 -0.19 FALSE ## 5 2022 WA 245 Perth 8203 Yokine ~ 37233 SZMEKU~ Sarah 5 FALSE FALSE AJP Animal~ 14 1.54 FALSE ## 6 2022 WA 245 Perth 8203 Yokine ~ 37327 GORMAN Patrick 6 TRUE TRUE ALP Austra~ 341 7.73 FALSE ## 7 2022 WA 245 Perth 8203 Yokine ~ 37273 NICKOLS Evan 7 FALSE FALSE LDP Libera~ 18 1.98 FALSE ## 8 2022 WA 245 Perth 8203 Yokine ~ 36507 EBERHA~ Sonya ~ 8 FALSE FALSE UAPP United~ 23 1.21 FALSE ## 9 2022 WA 245 Perth 8203 Yokine ~ 36628 PERKS Caroli~ 9 FALSE FALSE GRN The Gr~ 138 2.23 FALSE ## 10 2022 WA 245 Perth 8203 Yokine ~ 36601 DWYER David 10 FALSE FALSE LP Liberal 298 -15.7 FALSE ## 11 2022 WA 245 Perth 8203 Yokine ~ 37290 GYURU Aiden 11 FALSE FALSE CYA Austra~ 4 0.44 FALSE ## 12 2022 WA 245 Perth 8203 Yokine ~ 999 Inform~ Inform~ 999 FALSE FALSE Inform~ Inform~ 80 2.8 FALSE ## # ... with abbreviated variable names 1: PollingPlace, 2: CandidateID, 3: BallotPosition, 4: HistoricElected, 5: OrdinaryVotes, 6: SittingMemberFl It is also possible to restrict the results to selected polling places Additionally, it is possible to select one or more states instead of a group of divisions, e.g.: get_house_primary_vote(state=c(&quot;TAS&quot;),year=c(2019,2022),aggregation = TRUE) ## # A tibble: 86 x 14 ## Year StateAb DivisionID DivisionNm CandidateID Surname GivenNm BallotPosition Elected HistoricElected PartyAb PartyNm Sitti~1 Ordin~2 ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;int&gt; ## 1 2019 TAS 192 Bass 999 Informal Informal 999 FALSE FALSE Informal Informal FALSE 2962 ## 2 2019 TAS 192 Bass 32124 ARCHER Bridget 4 TRUE FALSE LP Liberal FALSE 25401 ## 3 2019 TAS 192 Bass 32327 HART Ross 2 FALSE TRUE ALP Australian La~ FALSE 20882 ## 4 2019 TAS 192 Bass 32379 WOODBURY Susan 3 FALSE FALSE AJP Animal Justic~ FALSE 1422 ## 5 2019 TAS 192 Bass 32399 COOPER Carl 7 FALSE FALSE NP The Nationals FALSE 783 ## 6 2019 TAS 192 Bass 32540 HALL Tom 1 FALSE FALSE GRN The Greens FALSE 6198 ## 7 2019 TAS 192 Bass 32545 ROARK Allan John 6 FALSE FALSE UAPP United Austra~ FALSE 2891 ## 8 2019 TAS 192 Bass 33590 LAMBERT Todd 5 FALSE FALSE IND Independent FALSE 2229 ## 9 2019 TAS 193 Braddon 999 Informal Informal 999 FALSE FALSE Informal Informal FALSE 5023 ## 10 2019 TAS 193 Braddon 32094 BRAKEY Craig 2 FALSE FALSE IND Independent FALSE 7046 ## # ... with 76 more rows, and abbreviated variable names 1: SittingMemberFl, 2: OrdinaryVotes It is also possible to filter results by one or more parties: get_house_primary_vote(state=c(&quot;NT&quot;),year=c(2019,2022),aggregation = TRUE, party_abb=c(&quot;ALP&quot;,&quot;CLP&quot;)) ## # A tibble: 8 x 14 ## Year StateAb DivisionID DivisionNm CandidateID Surname GivenNm BallotPosition Elected HistoricElected PartyAb PartyNm Sitti~1 Ordin~2 ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;int&gt; ## 1 2019 NT 306 Lingiari 32740 SNOWDON Warren 1 TRUE TRUE ALP Australian Lab~ FALSE 20125 ## 2 2019 NT 306 Lingiari 33045 PRICE Jacinta 6 FALSE FALSE CLP Country Libera~ FALSE 15918 ## 3 2019 NT 307 Solomon 32743 GOSLING Luke John 1 TRUE TRUE ALP Australian Lab~ FALSE 19484 ## 4 2019 NT 307 Solomon 33053 GANLEY Kathy 3 FALSE FALSE CLP Country Libera~ FALSE 18297 ## 5 2022 NT 306 Lingiari 36968 RYAN Damien 1 FALSE FALSE CLP NT CLP FALSE 13974 ## 6 2022 NT 306 Lingiari 37286 SCRYMGOUR Marion 5 TRUE FALSE ALP A.L.P. FALSE 15367 ## 7 2022 NT 307 Solomon 36937 MACFARLANE Tina 4 FALSE FALSE CLP NT CLP FALSE 11989 ## 8 2022 NT 307 Solomon 37280 GOSLING Luke 3 TRUE TRUE ALP A.L.P. FALSE 18891 ## # ... with abbreviated variable names 1: SittingMemberFl, 2: OrdinaryVotes house_primary_vote_summary() builds on the basic function and summarises data . house_primary_vote_summary(division = &quot;Brisbane&quot;, year=2022) ## # A tibble: 8 x 11 ## Year StateAb DivisionNm PartyAb PartyNm OrdinaryVotes GivenNm Surname Percentage_with_Informal Percen~1 Elected ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 2022 QLD Brisbane AJP Animal Justice Party 1235 Tiana KENNEDY 1.65 1.68 FALSE ## 2 2022 QLD Brisbane ALP Australian Labor Party 20346 Madonna JARRETT 27.1 27.7 FALSE ## 3 2022 QLD Brisbane GRN Queensland Greens 20985 Stephen BATES 28.0 28.6 TRUE ## 4 2022 QLD Brisbane Informal Informal 1566 Informal Informal 2.09 2.13 FALSE ## 5 2022 QLD Brisbane LDP Liberal Democrats 1115 Anthony BULL 1.49 1.52 FALSE ## 6 2022 QLD Brisbane LNP Liberal National Party of Queensland 26801 Trevor EVANS 35.7 36.5 FALSE ## 7 2022 QLD Brisbane ON Pauline Hanson&#39;s One Nation 1518 Trevor HOLD 2.02 2.07 FALSE ## 8 2022 QLD Brisbane UAPP United Australia Party 1430 Justin Marc KNUDSON 1.91 1.95 FALSE ## # ... with abbreviated variable name 1: Percentage Using the previous filters, it is possible to get ad-hoc summaries, for instance - all the ALP votes in Queensland in 2022, or the historic Liberal vote in Franklin. house_primary_vote_summary(state = &quot;QLD&quot;, year=2022,parties=&quot;ALP&quot;) ## # A tibble: 30 x 11 ## Year StateAb DivisionNm PartyAb PartyNm OrdinaryVotes GivenNm Surname Percentage_with_Informal Percentage Elected ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 2022 QLD Blair ALP Australian Labor Party 27323 Shayne NEUMANN 33.4 35.5 TRUE ## 2 2022 QLD Bonner ALP Australian Labor Party 20930 Tabatha YOUNG 29.3 30.0 FALSE ## 3 2022 QLD Bowman ALP Australian Labor Party 23196 Donisha DUFF 28.7 29.6 FALSE ## 4 2022 QLD Brisbane ALP Australian Labor Party 20346 Madonna JARRETT 27.1 27.7 FALSE ## 5 2022 QLD Capricornia ALP Australian Labor Party 20543 Russell ROBERTSON 26.9 28.7 FALSE ## 6 2022 QLD Dawson ALP Australian Labor Party 18921 Shane HAMILTON 23.8 24.9 FALSE ## 7 2022 QLD Dickson ALP Australian Labor Party 22988 Ali FRANCE 31.0 32.3 FALSE ## 8 2022 QLD Fadden ALP Australian Labor Party 18140 Letitia DEL FABBRO 21.7 22.8 FALSE ## 9 2022 QLD Fairfax ALP Australian Labor Party 18001 Sue FERGUSON 21.0 22.3 FALSE ## 10 2022 QLD Fisher ALP Australian Labor Party 19804 Judene ANDREWS 22.9 23.7 FALSE ## # ... with 20 more rows house_primary_vote_summary(division=&quot;Franklin&quot;,parties=&quot;LP&quot;) ## # A tibble: 7 x 11 ## Year StateAb DivisionNm PartyAb PartyNm OrdinaryVotes GivenNm Surname Percentage_with_Informal Percentage Elected ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 2004 TAS Franklin LP Liberal 21337 Henry FINNIS 37.6 39.0 FALSE ## 2 2007 TAS Franklin LP Liberal 22616 Vanessa GOODWIN 39.8 41.0 FALSE ## 3 2010 TAS Franklin LP Liberal 18386 Jane HOWLETT 32.0 33.3 FALSE ## 4 2013 TAS Franklin LP Liberal 21867 Bernadette BLACK 37.1 38.7 FALSE ## 5 2016 TAS Franklin LP Liberal 20754 Amanda-Sue MARKHAM 33.9 35.1 FALSE ## 6 2019 TAS Franklin LP Liberal 18591 Dean YOUNG 29.9 30.9 FALSE ## 7 2022 TAS Franklin LP Liberal 14374 Kristy Maree JOHNSON 24.5 25.9 FALSE 10.3 Plotting 10.3.1 Historic Trends The first plotting convenience function in this package allows comparing the evolution of primary voting across time. This function relies on house_primary_summary and uses many of its options. Its first use is to represent party trends in one electorate: house_primary_historic_plot(&quot;Canberra&quot;) As they can be many minor parties, it is sometimes useful just to focus on a number of parties. This function allows filtering by a number of parties or by filtering by the most voted in a certain year. In both cases, it is possible to consolidate others’ votes. house_primary_historic_plot(&quot;Canberra&quot;, parties =3, parties_year = 2022, include_others = TRUE ) Finally, it is possible to aggregate party acronyms - sometimes the same party has changed named or registered differently house_primary_historic_plot(division=&quot;Brisbane&quot;,parties=5, merge_parties = list(LNP=c(&quot;LNP&quot;,&quot;LNQ&quot;,&quot;LP&quot;), ON=c(&quot;HAN&quot;,&quot;ON&quot;))) 10.4 Results for one election This package also contains a convenience function to look at the primary vote results for one division. Lile the previous function, this also inherits many of the attributes of get_house_primary_vote. house_primary_comparison_plot(division = &quot;Kooyong&quot;, year=2022,individualise_IND = TRUE) The plots can also be displayed using bars, as shown below house_primary_comparison_plot(state=&quot;TAS&quot;,year=2022,parties=c(&quot;LP&quot;),plot_format = &quot;bar&quot;) "],["appendix-aussiemaps-vignette.html", "Chapter 11 (APPENDIX) {aussiemaps} Vignette 11.1 {aussiemaps} - Yet another maps package 11.2 Getting started. 11.3 Filtering via regular expressions 11.4 Even more complex filtering 11.5 Aggregation 11.6 Data Aggregation", " Chapter 11 (APPENDIX) {aussiemaps} Vignette Extracted from https://gh.carlosyanez.id.au/aussiemaps/articles/aussiemaps.html on Sunday 22 January 2023 11.1 {aussiemaps} - Yet another maps package This package has been built to facilitate the use of the geographic boundary files published by the Australian Bureau of Statistics (ABS). The ABS has published several boundary files - i.e. the Australian Statistical Geography Standard (ASGS) from 2006 onwards and the Australian Standard Geographical Classification (ASGC) before that - covering both: Statistical Geographic Structures created and maintained by the ABS - and used to collect data. Non-ABS structure, e.g Postal Areas, Electoral Divisions, LGA boundaries. This package has four versions of the above, aligned with Census years 2006, 2011,2016 and 2021. This makes it easy to mix use with Census data packs or the {auscensus} package. This package provides access to a processed version of those boundaries - as sf objects, allowing it to cater for the following scenarios: Get the boundaries of an electoral division across time. Get all the S1 or S1 areas within a Council area. Get all postcodes in a state or territory. This repository also contains the R script used to process the files. Although not tested, the functions could also accommodate BYO structures for other years. 11.2 Getting started. The core function of this package is get_map(), which retrieves the sf files. get_map provides several filters to narrow down the data retrieved and avoid getting everything unless is needed. The key parameters for this function are: How the data will be filtered (e.g. return only objects in a particular state, council or metro area) Which year/version of the data will be retrieved? Which aggregation will be used (e.g. which will be the resulting objects) Filters and column names follow the same name convention used in the original ABS files. The function list_attributes(), will present them in tibble format: list_attributes() |&gt; head(10) ## ℹ Running gh query ℹ Running gh query, got 100 records of about 200 ## # A tibble: 10 × 5 ## attributes `2006` `2011` `2016` `2021` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 CD_CODE CD_CODE_2006 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 CED_CODE CED_CODE_2006 CED_CODE_2011 CED_CODE_2016 CED_CODE_2021 ## 3 CED_NAME CED_NAME_2006 CED_NAME_2011 CED_NAME_2016 CED_NAME_2021 ## 4 IARE_CODE IARE_CODE_2006 IARE_CODE_2011 IARE_CODE_2016 IARE_CODE_2021 ## 5 IARE_NAME IARE_NAME_2006 IARE_NAME_2011 IARE_NAME_2016 IARE_NAME_2021 ## 6 ILOC_CODE ILOC_CODE_2006 ILOC_CODE_2011 ILOC_CODE_2016 ILOC_CODE_2021 ## 7 ILOC_NAME ILOC_NAME_2006 ILOC_NAME_2011 ILOC_NAME_2016 ILOC_NAME_2021 ## 8 IREG_CODE IREG_CODE_2006 IREG_CODE_2011 IREG_CODE_2016 IREG_CODE_2021 ## 9 IREG_NAME IREG_NAME_2006 IREG_NAME_2011 IREG_NAME_2016 IREG_NAME_2021 ## 10 LGA_CODE LGA_CODE_2006 LGA_CODE_2011 LGA_CODE_2016 LGA_CODE_2022 Let’s say we want to retrieve all SA1 in the City of Melbourne for 2016 - this can be done via: melbourne_sa1 &lt;- get_map(filters=list(LGA_NAME_2016=c(&quot;Melbourne&quot;)), year=2016, aggregation = c(&quot;SA1_MAINCODE_2016&quot;)) ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 249 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Victoria&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 249 features and 37 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 144.8971 ymin: -37.85067 xmax: 144.9914 ymax: -37.77545 ## Geodetic CRS: GDA94 #just an empty plot melbourne_sa1 |&gt; ggplot()+ geom_sf(fill=&quot;azure1&quot;) + theme_void() + labs(title=&quot;SA1s in the City of Melbourne&quot;) 11.3 Filtering via regular expressions The filter arguments are intended to be regular expressions, for instance: preston &lt;- get_map(filters=list(SSC_NAME_2016=c(&quot;Preston&quot;)), year=2016, aggregation = c(&quot;SSC_NAME_2016&quot;)) ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 119 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_New.South.Wales&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 36 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 150.8487 ymin: -33.95678 xmax: 150.8979 ymax: -33.9263 ## Geodetic CRS: GDA94 ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 119 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Queensland&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 5 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 148.6178 ymin: -27.68302 xmax: 152.0004 ymax: -20.34465 ## Geodetic CRS: GDA94 ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 119 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Tasmania&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 2 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 145.9943 ymin: -41.3658 xmax: 146.1147 ymax: -41.24951 ## Geodetic CRS: GDA94 ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 119 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Victoria&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 74 features and 37 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 144.979 ymin: -37.75573 xmax: 145.0383 ymax: -37.72792 ## Geodetic CRS: GDA94 ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 119 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Western.Australia&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 2 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 115.6286 ymin: -33.44906 xmax: 116.1876 ymax: -32.79339 ## Geodetic CRS: GDA94 preston |&gt; select(SSC_NAME_2016,UCL_NAME_2016,STE_NAME_2016) ## Simple feature collection with 8 features and 3 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 115.6286 ymin: -41.3658 xmax: 152.0004 ymax: -20.34465 ## Geodetic CRS: GDA94 ## # A tibble: 8 × 4 ## SSC_NAME_2016 UCL_NAME_2016 STE_NAME_2016 geom ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [°]&gt; ## 1 Prestons Sydney New South Wales (((150.855 -33.95284, 150.8542 -33.95265, 150.8528 -33.95232, 150… ## 2 Preston (Vic.) Melbourne Victoria (((144.9984 -37.7301, 145.0005 -37.73032, 145.002 -37.73047, 145.… ## 3 Preston (Toowoomba - Qld) Remainder of State/Territory (Qld) Queensland (((151.9545 -27.64808, 151.9559 -27.64938, 151.9545 -27.64808, 15… ## 4 Preston (Whitsunday - Qld) Remainder of State/Territory (Qld) Queensland (((148.6227 -20.3747, 148.6229 -20.37434, 148.623 -20.37383, 148.… ## 5 Preston Beach Remainder of State/Territory (WA) Western Australia (((115.6492 -32.88399, 115.6491 -32.88388, 115.649 -32.88336, 115… ## 6 Preston Settlement Remainder of State/Territory (WA) Western Australia (((116.117 -33.40392, 116.122 -33.40121, 116.1222 -33.39111, 116.… ## 7 Preston (Tas.) Remainder of State/Territory (Tas.) Tasmania (((146.076 -41.33851, 146.0757 -41.33829, 146.0756 -41.3382, 146.… ## 8 South Preston Remainder of State/Territory (Tas.) Tasmania (((146.076 -41.33851, 146.0759 -41.33858, 146.0758 -41.33867, 146… Whereas prestons &lt;- get_map(filters=list(SSC_NAME_2016=c(&quot;^Pres&quot;), STE_NAME_2016=c(&quot;Wales&quot;,&quot;^T&quot;) ), year=2016, aggregation = c(&quot;SSC_NAME_2016&quot;)) ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 38 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_New.South.Wales&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 36 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 150.8487 ymin: -33.95678 xmax: 150.8979 ymax: -33.9263 ## Geodetic CRS: GDA94 ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 38 features with 36 fields without geometries. ## Reading query `SELECT * FROM &#39;2016_Tasmania&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 2 features and 35 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 146.0066 ymin: -41.33851 xmax: 146.1147 ymax: -41.09649 ## Geodetic CRS: GDA94 prestons |&gt; select(SSC_NAME_2016,UCL_NAME_2016,STE_NAME_2016) ## Simple feature collection with 3 features and 3 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 146.0066 ymin: -41.33851 xmax: 150.8979 ymax: -33.9263 ## Geodetic CRS: GDA94 ## # A tibble: 3 × 4 ## SSC_NAME_2016 UCL_NAME_2016 STE_NAME_2016 geom ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;POLYGON [°]&gt; ## 1 Prestons Sydney New South Wales ((150.855 -33.95284, 150.8542 -33.95265, 150.8528 -33.95232, 150.8518 -33.952… ## 2 Preservation Bay Remainder of State/Territory (Tas.) Tasmania ((146.0401 -41.09734, 146.0403 -41.09661, 146.0403 -41.09649, 146.0404 -41.09… ## 3 Preston (Tas.) Remainder of State/Territory (Tas.) Tasmania ((146.0962 -41.25072, 146.0963 -41.2506, 146.0964 -41.25055, 146.0964 -41.250… 11.4 Even more complex filtering If more complex subsetting is needed, it is possible to pass a table with the elements to be selected. In order to do that, list_structure() comes to help. This function uses the same year and filters parameters than get_map() (actually this function calls the former if no table is provided). Once you have the dataset, you can use any ad-hoc filter to get the needed structures. For example greater_sydney &lt;- list_structure(year=2021,filters=list(GCCSA_NAME_2021=&quot;Greater Sydney&quot;)) #use_cache option stores the results/reuses pre-processed results sydney_area &lt;- get_map(filter_table = greater_sydney, year=2021, aggregation = &quot;GCCSA_NAME_2021&quot;, use_cache = TRUE) ## loading from cache: C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/8c99638c.gpkg ## Reading layer `8c99638c&#39; from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\8c99638c.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 1 feature and 39 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 149.9719 ymin: -34.33116 xmax: 151.6301 ymax: -33.00031 ## Geodetic CRS: GDA2020 #outline # all suburbs starting wit A suburbs_a_filter &lt;- greater_sydney |&gt; filter(str_detect(SAL_NAME_2021,&quot;^A&quot;)) suburbs_a &lt;- get_map(filter_table = suburbs_a_filter, year=2021, aggregation = &quot;SAL_NAME_2021&quot;) |&gt; mutate(border=&quot;orange&quot;,fill=&quot;orange&quot;) ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 473 features with 42 fields without geometries. ## Reading query `SELECT * FROM &#39;2021_New.South.Wales&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 473 features and 40 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 150.6731 ymin: -34.25982 xmax: 151.4437 ymax: -33.25952 ## Geodetic CRS: GDA2020 ggplot() + geom_sf(data=sydney_area,fill=&quot;white&quot;,colour=&quot;black&quot;)+ geom_sf(data=suburbs_a,fill=&quot;orange&quot;) + labs(title=&quot;Suburbs starting with A - Sydney&quot;) + theme_void() 11.5 Aggregation It is worth noticing that the aggregation parameter accepts more than one variable. Those parameters are passed to dplyr::group_by() before aggregation - thus more variables will impact how sf objects are aggregated. For instance, if we look at the postal areas (ABS approximation of a postcode) in the cities of Melbourne and Port Phillip: poas_inner_melbourne &lt;- get_map(filters=list(LGA_NAME_2022=c(&quot;Melbourne&quot;,&quot;Phillip$&quot;)), year=2021, aggregation = c(&quot;POA_NAME_2021&quot;,&quot;LGA_NAME_2022&quot;)) ## Updating layer `id&#39; to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg&#39; using driver `GPKG&#39; ## Writing 626 features with 42 fields without geometries. ## Reading query `SELECT * FROM &#39;2021_Victoria&#39; WHERE id IN (SELECT id FROM id)&#39; ## from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 626 features and 43 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 144.8971 ymin: -37.89172 xmax: 145.0105 ymax: -37.77543 ## Geodetic CRS: GDA2020 poas_inner_melbourne |&gt; mutate(colour=case_when( POA_NAME_2021==&quot;3004&quot; ~ &quot;orange&quot;, TRUE ~ &quot;grey&quot; )) |&gt; ggplot()+ geom_sf(aes(fill=colour,colour=LGA_NAME_2022)) + scale_fill_identity() + theme_void() + labs(title=&quot;Postcode 3004 extends across two LGAs&quot;) ## Using external data This package provides sf data, thus the result can be easily merged with any other data frame. Since data has been taken from the ABS and the output contains both names and codes of geographic structures, data can be joined using an un-ambiguous key. Furthermore, with {auscensus}, this package can be used as data filters to retrieve said data in the first place. For example: # Chileans by Commonwealth Electoral Divisions in Metropolitan Brisbane, 2021 attr &lt;- list_structure(year=2021,filters=list(GCCSA_NAME_2021=c(&quot;Brisbane&quot;))) |&gt; distinct(CED_NAME_2021) chileans &lt;- auscensus::get_census_summary(table_number= &quot;09&quot;, selected_years = &quot;2021&quot;, geo_structure = &quot;CED&quot;, geo_unit_names = attr$CED_NAME_2021, attribute = list(Chileans=c(&quot;Persons_chile_total&quot;)), reference_total = list(Total=c(&quot;Persons_total_total&quot;)), percentage_scale =100) brisbane_ced &lt;- get_map(filters = list(GCCSA_NAME_2021=c(&quot;Brisbane&quot;)), year = 2021, aggregation = c(&quot;CED_NAME_2021&quot;), use_cache = TRUE) ## loading from cache: C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/b26452fe.gpkg ## Reading layer `b26452fe&#39; from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\b26452fe.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 15 features and 39 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 152.0734 ymin: -28.36387 xmax: 153.5467 ymax: -26.45233 ## Geodetic CRS: GDA2020 chileans$Value ## [1] 85 109 64 228 44 90 241 87 66 180 267 107 96 223 66 brisbane_ced |&gt; left_join(chileans,by=c(&quot;CED_NAME_2021&quot;=&quot;Unit&quot;)) |&gt; ggplot(aes(fill=Value,colour=Value)) + geom_sf() + scale_fill_continuous()+ labs(title=&quot;Chileans in Bribane&#39;s Federal Electorates&quot;) + theme_void() 11.6 Data Aggregation As a bonus function, geo_aggregate() aggregates data, transforming between geographic structures. For instance, let’s imagine that for the previous case, it is only possible to get data by SA2. geo_aggregate() can aggregate the data to obtain an approximation for each electorate. When an SA1 is not fully contained by an electorate, the function will use the overlapping area as the weighting factor. attr &lt;- list_structure(year=2021,filters=list(GCCSA_NAME_2021=c(&quot;Brisbane&quot;))) |&gt; distinct(SA2_CODE_2021) chileans_sa2 &lt;- auscensus::get_census_summary(table_number= &quot;09&quot;, selected_years = &quot;2021&quot;, geo_structure = &quot;SA2&quot;, geo_unit_codes = attr$SA2_CODE_2021, attribute = list(Chileans=c(&quot;Persons_chile_total&quot;))) |&gt; rename(&quot;SA2_CODE_2021&quot;=&quot;Census_Code&quot;) # please note these Electoral divisions are not built from SA2s - proportional allocation will result in factional # Therefore - This is an approximation chileans &lt;- geo_aggregate(original_data = chileans_sa2, values_col = &quot;Value&quot;, original_geo = &quot;SA2_CODE_2021&quot;, new_geo = &quot;CED_NAME_2021&quot;, grouping_col = c(&quot;Year&quot;,&quot;Attribute&quot;), year=2021) |&gt; rename(&quot;Unit&quot;=&quot;CED_NAME_2021&quot;) brisbane_ced |&gt; left_join(chileans,by=c(&quot;CED_NAME_2021&quot;=&quot;Unit&quot;)) |&gt; ggplot(aes(fill=Value,colour=Value)) + geom_sf() + scale_fill_continuous()+ labs(title=&quot;Chileans in Bribane&#39;s Federal Electorates&quot;) + theme_void() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
